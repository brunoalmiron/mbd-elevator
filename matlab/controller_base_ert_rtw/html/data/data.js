var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"controller_base","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"C:\\Users\\rodri\\git\\bruno\\mbd-elevator\\matlab\\controller_base_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\r\n * Sponsored Third Party Support License -- for use only to support\r\n * products interfaced to MathWorks software under terms specified in your\r\n * company's restricted use license agreement.\r\n *\r\n * File: ert_main.c\r\n *\r\n * Code generated for Simulink model 'controller_base'.\r\n *\r\n * Model version                  : 1.8\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Sat Jul 13 15:09:24 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"controller_base.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"MW_target_hardware_resources.h\"\r\n\r\nvolatile int IsrOverrun = 0;\r\nstatic boolean_T OverrunFlag = 0;\r\nvoid rt_OneStep(void)\r\n{\r\n  /* Check for overrun. Protect OverrunFlag against preemption */\r\n  if (OverrunFlag++) {\r\n    IsrOverrun = 1;\r\n    OverrunFlag--;\r\n    return;\r\n  }\r\n\r\n  enableTimer0Interrupt();\r\n  controller_base_step();\r\n\r\n  /* Get model outputs here */\r\n  disableTimer0Interrupt();\r\n  OverrunFlag--;\r\n}\r\n\r\nvolatile boolean_T stopRequested;\r\nvolatile boolean_T runModel;\r\nint main(void)\r\n{\r\n  float modelBaseRate = 0.1;\r\n  float systemClock = 90;\r\n\r\n  /* Initialize variables */\r\n  stopRequested = false;\r\n  runModel = false;\r\n  c2000_flash_init();\r\n  init_board();\r\n\r\n#if defined(MW_EXEC_PROFILER_ON) || (defined(MW_EXTMODE_RUNNING) && !defined(XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME))\r\n\r\n  hardwareTimer1Init();\r\n\r\n#endif\r\n\r\n  ;\r\n  bootloaderInit();\r\n  rtmSetErrorStatus(controller_base_M, 0);\r\n  controller_base_initialize();\r\n  globalInterruptDisable();\r\n  configureTimer0(modelBaseRate, systemClock);\r\n  runModel =\r\n    rtmGetErrorStatus(controller_base_M) == (NULL);\r\n  enableTimer0Interrupt();\r\n  globalInterruptEnable();\r\n  while (runModel) {\r\n    stopRequested = !(\r\n                      rtmGetErrorStatus(controller_base_M) == (NULL));\r\n  }\r\n\r\n  /* Terminate model */\r\n  controller_base_terminate();\r\n  globalInterruptDisable();\r\n  return 0;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"controller_base.c","type":"source","group":"model","path":"C:\\Users\\rodri\\git\\bruno\\mbd-elevator\\matlab\\controller_base_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Sponsored Third Party Support License -- for use only to support\r\n * products interfaced to MathWorks software under terms specified in your\r\n * company's restricted use license agreement.\r\n *\r\n * File: controller_base.c\r\n *\r\n * Code generated for Simulink model 'controller_base'.\r\n *\r\n * Model version                  : 1.8\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Sat Jul 13 15:09:24 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"controller_base.h\"\r\n#include <string.h>\r\n\r\n/* Block signals (default storage) */\r\nB_controller_base_T controller_base_B;\r\n\r\n/* Block states (default storage) */\r\nDW_controller_base_T controller_base_DW;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL_controller_base_T controller_base_M_;\r\nRT_MODEL_controller_base_T *const controller_base_M = &controller_base_M_;\r\n\r\n/* Model step function */\r\nvoid controller_base_step(void)\r\n{\r\n  /* S-Function (c280xgpio_di): '<Root>/Digital Input2' */\r\n  {\r\n    controller_base_B.DigitalInput2[0] = GpioDataRegs.GPADAT.bit.GPIO19;\r\n    controller_base_B.DigitalInput2[1] = GpioDataRegs.GPADAT.bit.GPIO20;\r\n    controller_base_B.DigitalInput2[2] = GpioDataRegs.GPADAT.bit.GPIO21;\r\n  }\r\n\r\n  /* SignalConversion generated from: '<Root>/Vector Concatenate1' incorporates:\r\n   *  Concatenate: '<Root>/Vector Concatenate1'\r\n   */\r\n  controller_base_B.VectorConcatenate1[0] = controller_base_B.DigitalInput2[1];\r\n\r\n  /* SignalConversion generated from: '<Root>/Vector Concatenate1' incorporates:\r\n   *  Concatenate: '<Root>/Vector Concatenate1'\r\n   */\r\n  controller_base_B.VectorConcatenate1[1] = controller_base_B.DigitalInput2[0];\r\n\r\n  /* SignalConversion generated from: '<Root>/Vector Concatenate1' incorporates:\r\n   *  Concatenate: '<Root>/Vector Concatenate1'\r\n   */\r\n  controller_base_B.VectorConcatenate1[2] = controller_base_B.DigitalInput2[2];\r\n\r\n  /* S-Function (c280xgpio_do): '<Root>/Digital Output1' */\r\n  {\r\n    if (controller_base_B.VectorConcatenate1[0]) {\r\n      GpioDataRegs.GPASET.bit.GPIO0 = 1U;\r\n    } else {\r\n      GpioDataRegs.GPACLEAR.bit.GPIO0 = 1U;\r\n    }\r\n\r\n    if (controller_base_B.VectorConcatenate1[1]) {\r\n      GpioDataRegs.GPASET.bit.GPIO3 = 1U;\r\n    } else {\r\n      GpioDataRegs.GPACLEAR.bit.GPIO3 = 1U;\r\n    }\r\n\r\n    if (controller_base_B.VectorConcatenate1[2]) {\r\n      GpioDataRegs.GPASET.bit.GPIO6 = 1U;\r\n    } else {\r\n      GpioDataRegs.GPACLEAR.bit.GPIO6 = 1U;\r\n    }\r\n  }\r\n}\r\n\r\n/* Model initialize function */\r\nvoid controller_base_initialize(void)\r\n{\r\n  /* Registration code */\r\n\r\n  /* initialize error status */\r\n  rtmSetErrorStatus(controller_base_M, (NULL));\r\n\r\n  /* block I/O */\r\n  (void) memset(((void *) &controller_base_B), 0,\r\n                sizeof(B_controller_base_T));\r\n\r\n  /* states (dwork) */\r\n  (void) memset((void *)&controller_base_DW, 0,\r\n                sizeof(DW_controller_base_T));\r\n\r\n  /* Start for S-Function (c280xgpio_di): '<Root>/Digital Input2' */\r\n  EALLOW;\r\n  GpioCtrlRegs.GPAMUX2.all &= 0xFFFFF03FU;\r\n  GpioCtrlRegs.GPADIR.all &= 0xFFC7FFFFU;\r\n  EDIS;\r\n\r\n  /* Start for S-Function (c280xgpio_do): '<Root>/Digital Output1' */\r\n  EALLOW;\r\n  GpioCtrlRegs.GPAMUX1.all &= 0xFFFFCF3CU;\r\n  GpioCtrlRegs.GPADIR.all |= 0x49U;\r\n  EDIS;\r\n}\r\n\r\n/* Model terminate function */\r\nvoid controller_base_terminate(void)\r\n{\r\n  /* (no terminate code required) */\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"controller_base.h","type":"header","group":"model","path":"C:\\Users\\rodri\\git\\bruno\\mbd-elevator\\matlab\\controller_base_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Sponsored Third Party Support License -- for use only to support\r\n * products interfaced to MathWorks software under terms specified in your\r\n * company's restricted use license agreement.\r\n *\r\n * File: controller_base.h\r\n *\r\n * Code generated for Simulink model 'controller_base'.\r\n *\r\n * Model version                  : 1.8\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Sat Jul 13 15:09:24 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef controller_base_h_\r\n#define controller_base_h_\r\n#ifndef controller_base_COMMON_INCLUDES_\r\n#define controller_base_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#include \"rtw_continuous.h\"\r\n#include \"rtw_solver.h\"\r\n#include \"c2000BoardSupport.h\"\r\n#include \"F2806x_Device.h\"\r\n#include \"F2806x_Gpio.h\"\r\n#endif                                 /* controller_base_COMMON_INCLUDES_ */\r\n\r\n#include <stddef.h>\r\n#include \"controller_base_types.h\"\r\n#include <string.h>\r\n#include \"MW_target_hardware_resources.h\"\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n/* Block signals (default storage) */\r\ntypedef struct {\r\n  real32_T DigitalInput2[3];           /* '<Root>/Digital Input2' */\r\n  real32_T VectorConcatenate1[3];      /* '<Root>/Vector Concatenate1' */\r\n} B_controller_base_T;\r\n\r\n/* Block states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  int32_T DigitalOutput1_FRAC_LEN;     /* '<Root>/Digital Output1' */\r\n} DW_controller_base_T;\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_controller_base_T {\r\n  const char_T * volatile errorStatus;\r\n};\r\n\r\n/* Block signals (default storage) */\r\nextern B_controller_base_T controller_base_B;\r\n\r\n/* Block states (default storage) */\r\nextern DW_controller_base_T controller_base_DW;\r\n\r\n/* Model entry point functions */\r\nextern void controller_base_initialize(void);\r\nextern void controller_base_step(void);\r\nextern void controller_base_terminate(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL_controller_base_T *const controller_base_M;\r\nextern volatile boolean_T stopRequested;\r\nextern volatile boolean_T runModel;\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'controller_base'\r\n */\r\n#endif                                 /* controller_base_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"controller_base_private.h","type":"header","group":"model","path":"C:\\Users\\rodri\\git\\bruno\\mbd-elevator\\matlab\\controller_base_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Sponsored Third Party Support License -- for use only to support\r\n * products interfaced to MathWorks software under terms specified in your\r\n * company's restricted use license agreement.\r\n *\r\n * File: controller_base_private.h\r\n *\r\n * Code generated for Simulink model 'controller_base'.\r\n *\r\n * Model version                  : 1.8\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Sat Jul 13 15:09:24 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef controller_base_private_h_\r\n#define controller_base_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"controller_base_types.h\"\r\n#include \"rtw_continuous.h\"\r\n#include \"rtw_solver.h\"\r\n#endif                                 /* controller_base_private_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"controller_base_types.h","type":"header","group":"model","path":"C:\\Users\\rodri\\git\\bruno\\mbd-elevator\\matlab\\controller_base_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Sponsored Third Party Support License -- for use only to support\r\n * products interfaced to MathWorks software under terms specified in your\r\n * company's restricted use license agreement.\r\n *\r\n * File: controller_base_types.h\r\n *\r\n * Code generated for Simulink model 'controller_base'.\r\n *\r\n * Model version                  : 1.8\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Sat Jul 13 15:09:24 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef controller_base_types_h_\r\n#define controller_base_types_h_\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_controller_base_T RT_MODEL_controller_base_T;\r\n\r\n#endif                                 /* controller_base_types_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Users\\rodri\\git\\bruno\\mbd-elevator\\matlab\\controller_base_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Sponsored Third Party Support License -- for use only to support\r\n * products interfaced to MathWorks software under terms specified in your\r\n * company's restricted use license agreement.\r\n *\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model 'controller_base'.\r\n *\r\n * Model version                  : 1.8\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Sat Jul 13 15:09:24 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: Texas Instruments->C2000\r\n *   Number of bits:     char:  16    short:   16    int:  16\r\n *                       long:  32    long long:  64\r\n *                       native word size:  16\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *                                                                       *\r\n *                                                                       *\r\n *   Note:  Because the specified hardware does not have native support  *\r\n *          for all data sizes, some data types are actually typedef'ed  *\r\n *          from larger native data sizes.  The following data types are *\r\n *          not in the ideal native data types:                          *\r\n *                                                                       *\r\n *          int8_T, uint8_T                                              *\r\n *=======================================================================*/\r\ntypedef int int8_T;\r\ntypedef unsigned int uint8_T;\r\ntypedef int int16_T;\r\ntypedef unsigned int uint16_T;\r\ntypedef long int32_T;\r\ntypedef unsigned long uint32_T;\r\ntypedef long long int64_T;\r\ntypedef unsigned long long uint64_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T, ulonglong_T.           *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned int boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef unsigned long long ulonglong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*===========================================================================*\r\n * Complex number type definitions                                           *\r\n *===========================================================================*/\r\n#define CREAL_T\r\n\r\ntypedef struct {\r\n  real32_T re;\r\n  real32_T im;\r\n} creal32_T;\r\n\r\ntypedef struct {\r\n  real64_T re;\r\n  real64_T im;\r\n} creal64_T;\r\n\r\ntypedef struct {\r\n  real_T re;\r\n  real_T im;\r\n} creal_T;\r\n\r\n#define CINT8_T\r\n\r\ntypedef struct {\r\n  int8_T re;\r\n  int8_T im;\r\n} cint8_T;\r\n\r\n#define CUINT8_T\r\n\r\ntypedef struct {\r\n  uint8_T re;\r\n  uint8_T im;\r\n} cuint8_T;\r\n\r\n#define CINT16_T\r\n\r\ntypedef struct {\r\n  int16_T re;\r\n  int16_T im;\r\n} cint16_T;\r\n\r\n#define CUINT16_T\r\n\r\ntypedef struct {\r\n  uint16_T re;\r\n  uint16_T im;\r\n} cuint16_T;\r\n\r\n#define CINT32_T\r\n\r\ntypedef struct {\r\n  int32_T re;\r\n  int32_T im;\r\n} cint32_T;\r\n\r\n#define CUINT32_T\r\n\r\ntypedef struct {\r\n  uint32_T re;\r\n  uint32_T im;\r\n} cuint32_T;\r\n\r\n#define CINT64_T\r\n\r\ntypedef struct {\r\n  int64_T re;\r\n  int64_T im;\r\n} cint64_T;\r\n\r\n#define CUINT64_T\r\n\r\ntypedef struct {\r\n  uint64_T re;\r\n  uint64_T im;\r\n} cuint64_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647L))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647L-1L))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFUL))\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"C:\\Users\\rodri\\git\\bruno\\mbd-elevator\\matlab\\controller_base_ert_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n * Sponsored Third Party Support License -- for use only to support\r\n * products interfaced to MathWorks software under terms specified in your\r\n * company's restricted use license agreement.\r\n *\r\n * File: rtmodel.h\r\n *\r\n * Code generated for Simulink model 'controller_base'.\r\n *\r\n * Model version                  : 1.8\r\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n * C/C++ source code generated on : Sat Jul 13 15:09:24 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef rtmodel_h_\r\n#define rtmodel_h_\r\n#include \"controller_base.h\"\r\n\r\n/* Macros generated for backwards compatibility  */\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((void*) 0)\r\n#endif\r\n#endif                                 /* rtmodel_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"F2806x_Adc.c","type":"source","group":"legacy","path":"C:\\Users\\rodri\\git\\bruno\\mbd-elevator\\matlab\\controller_base_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ti\\controlSUITE\\device_support\\f2806x\\v151\\F2806x_common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\r\n//\r\n// FILE:    F2806x_Adc.c\r\n//\r\n// TITLE:   F2806x ADC Initialization & Support Functions.\r\n//\r\n//###########################################################################\r\n// $TI Release: F2806x C/C++ Header Files and Peripheral Examples V151 $\r\n// $Release Date: February  2, 2016 $\r\n// $Copyright: Copyright (C) 2011-2016 Texas Instruments Incorporated -\r\n//             http://www.ti.com/ ALL RIGHTS RESERVED $\n//###########################################################################\r\n\r\n#include \"F2806x_Device.h\"     // F2806x Headerfile Include File\r\n#include \"F2806x_Examples.h\"   // F2806x Examples Include File\r\n\r\n#define ADC_usDELAY  1000L\r\n\r\n//---------------------------------------------------------------------------\r\n// InitAdc:\r\n//---------------------------------------------------------------------------\r\n// This function initializes ADC to a known state.\r\n//\r\n// NOTE: ADC INIT IS DIFFERENT ON F2806x DEVICES COMPARED TO OTHER 28X DEVICES\r\n//\r\n//  *IMPORTANT*\r\n//  IF RUNNING FROM FLASH, PLEASE COPY OVER THE SECTION \"ramfuncs\"  FROM FLASH\r\n//  TO RAM PRIOR TO CALLING InitSysCtrl(). THIS PREVENTS THE MCU FROM THROWING \r\n//  AN EXCEPTION WHEN A CALL TO DELAY_US() IS MADE. \r\n//\r\nvoid InitAdc(void)\r\n{\r\n    extern void DSP28x_usDelay(Uint32 Count);\r\n\r\n    // *IMPORTANT*\r\n    // The Device_cal function, which copies the ADC calibration values from TI reserved\r\n    // OTP into the ADCREFSEL and ADCOFFTRIM registers, occurs automatically in the\r\n    // Boot ROM. If the boot ROM code is bypassed during the debug process, the\r\n    // following function MUST be called for the ADC to function according\r\n    // to specification. The clocks to the ADC MUST be enabled before calling this\r\n    // function.\r\n    // See the device data manual and/or the ADC Reference\r\n    // Manual for more information.\r\n\r\n        EALLOW;\r\n        SysCtrlRegs.PCLKCR0.bit.ADCENCLK = 1;\r\n        (*Device_cal)();\r\n        EDIS;\r\n\r\n    // To powerup the ADC the ADCENCLK bit should be set first to enable\r\n    // clocks, followed by powering up the bandgap, reference circuitry, and ADC core.\r\n    // Before the first conversion is performed a 5ms delay must be observed\r\n    // after power up to give all analog circuits time to power up and settle\r\n\r\n    // Please note that for the delay function below to operate correctly the\r\n    // CPU_RATE define statement in the F2806x_Examples.h file must\r\n    // contain the correct CPU clock period in nanoseconds.\r\n    EALLOW;\r\n    AdcRegs.ADCCTL1.bit.ADCBGPWD  = 1;      // Power ADC BG\r\n    AdcRegs.ADCCTL1.bit.ADCREFPWD = 1;      // Power reference\r\n    AdcRegs.ADCCTL1.bit.ADCPWDN   = 1;      // Power ADC\r\n    AdcRegs.ADCCTL1.bit.ADCENABLE = 1;      // Enable ADC\r\n    AdcRegs.ADCCTL1.bit.ADCREFSEL = 0;      // Select interal BG\r\n    EDIS;\r\n\r\n    DELAY_US(ADC_usDELAY);         // Delay before converting ADC channels\r\n\r\n    EALLOW;\r\n    AdcRegs.ADCCTL2.bit.CLKDIV2EN = 1;\r\n    EDIS;\r\n\r\n    DELAY_US(ADC_usDELAY);         // Delay before converting ADC channels\r\n}\r\n\r\nvoid InitAdcAio()\r\n{\r\n\r\n   EALLOW;\r\n\r\n/* Configure ADC pins using AIO regs*/\r\n// This specifies which of the possible AIO pins will be Analog input pins.\r\n// NOTE: AIO1,3,5,7-9,11,13,15 are analog inputs in all AIOMUX1 configurations.\r\n// Comment out other unwanted lines.\r\n\r\n    GpioCtrlRegs.AIOMUX1.bit.AIO2 = 2;    // Configure AIO2 for A2 (analog input) operation\r\n    GpioCtrlRegs.AIOMUX1.bit.AIO4 = 2;    // Configure AIO4 for A4 (analog input) operation\r\n    GpioCtrlRegs.AIOMUX1.bit.AIO6 = 2;    // Configure AIO6 for A6 (analog input) operation\r\n    GpioCtrlRegs.AIOMUX1.bit.AIO10 = 2;   // Configure AIO10 for B2 (analog input) operation\r\n    GpioCtrlRegs.AIOMUX1.bit.AIO12 = 2;   // Configure AIO12 for B4 (analog input) operation\r\n    GpioCtrlRegs.AIOMUX1.bit.AIO14 = 2;   // Configure AIO14 for B6 (analog input) operation\r\n\r\n    EDIS;\r\n}\r\n\r\n\r\n/* AdcoffsetSelfCal-\r\n   This function re-calibrates the ADC zero offset error by converting the VREFLO reference with\r\n   the ADC and modifying the ADCOFFTRIM register. VREFLO is sampled by the ADC using an internal\r\n   MUX select which connects VREFLO to A5 without sacrificing an external ADC pin. This\r\n   function calls two other functions:\r\n   - AdcChanSelect(channel) – selects the ADC channel to convert\r\n   - AdcConversion() – initiates several ADC conversions and returns the average\r\n*/\r\nvoid AdcOffsetSelfCal()\r\n{\r\n    Uint16 AdcConvMean;\r\n    EALLOW;\r\n    AdcRegs.ADCCTL1.bit.ADCREFSEL = 0;                  //Select internal reference mode\r\n    AdcRegs.ADCCTL1.bit.VREFLOCONV = 1;                 //Select VREFLO internal connection on B5\r\n    AdcChanSelect(13);                                  //Select channel B5 for all SOC\r\n    AdcRegs.ADCOFFTRIM.bit.OFFTRIM = 80;                //Apply artificial offset (+80) to account for a negative offset that may reside in the ADC core\r\n    AdcConvMean = AdcConversion();                      //Capture ADC conversion on VREFLO\r\n    AdcRegs.ADCOFFTRIM.bit.OFFTRIM = 80 - AdcConvMean;  //Set offtrim register with new value (i.e remove artical offset (+80) and create a two's compliment of the offset error)\r\n    AdcRegs.ADCCTL1.bit.VREFLOCONV = 0;                 //Select external ADCIN5 input pin on B5\r\n    EDIS;\r\n}\r\n\r\n/*  AdcChanSelect-\r\n    This function selects the ADC channel to convert by setting all SOC channel selects to a single channel.\r\n\r\n     * IMPORTANT * This function will overwrite previous SOC channel select settings. Recommend saving\r\n           the previous settings.\r\n */\r\nvoid AdcChanSelect(Uint16 ch_no)\r\n{\r\n    AdcRegs.ADCSOC0CTL.bit.CHSEL= ch_no;\r\n    AdcRegs.ADCSOC1CTL.bit.CHSEL= ch_no;\r\n    AdcRegs.ADCSOC2CTL.bit.CHSEL= ch_no;\r\n    AdcRegs.ADCSOC3CTL.bit.CHSEL= ch_no;\r\n    AdcRegs.ADCSOC4CTL.bit.CHSEL= ch_no;\r\n    AdcRegs.ADCSOC5CTL.bit.CHSEL= ch_no;\r\n    AdcRegs.ADCSOC6CTL.bit.CHSEL= ch_no;\r\n    AdcRegs.ADCSOC7CTL.bit.CHSEL= ch_no;\r\n    AdcRegs.ADCSOC8CTL.bit.CHSEL= ch_no;\r\n    AdcRegs.ADCSOC9CTL.bit.CHSEL= ch_no;\r\n    AdcRegs.ADCSOC10CTL.bit.CHSEL= ch_no;\r\n    AdcRegs.ADCSOC11CTL.bit.CHSEL= ch_no;\r\n    AdcRegs.ADCSOC12CTL.bit.CHSEL= ch_no;\r\n    AdcRegs.ADCSOC13CTL.bit.CHSEL= ch_no;\r\n    AdcRegs.ADCSOC14CTL.bit.CHSEL= ch_no;\r\n    AdcRegs.ADCSOC15CTL.bit.CHSEL= ch_no;\r\n} //end AdcChanSelect\r\n\r\n/* AdcConversion -\r\n   This function initiates several ADC conversions and returns the average. It uses ADCINT1 and ADCINT2\r\n   to \"ping-pong\" between SOC0-7 and SOC8-15 and is referred to as \"ping-pong\" sampling.\r\n\r\n     * IMPORTANT * This function will overwrite previous ADC settings. Recommend saving previous settings.\r\n*/\r\nUint16 AdcConversion(void)\r\n{\r\n    Uint16 index, SampleSize, Mean, ACQPS_Value;\r\n    Uint32 Sum;\r\n\r\n    index       = 0;            //initialize index to 0\r\n    SampleSize  = 256;          //set sample size to 256 (**NOTE: Sample size must be multiples of 2^x where is an integer >= 4)\r\n    Sum         = 0;            //set sum to 0\r\n    Mean        = 999;          //initialize mean to known value\r\n\r\n    //Set the ADC sample window to the desired value (Sample window = ACQPS + 1)\r\n    ACQPS_Value = 6;\r\n    AdcRegs.ADCSOC0CTL.bit.ACQPS  = ACQPS_Value;\r\n    AdcRegs.ADCSOC1CTL.bit.ACQPS  = ACQPS_Value;\r\n    AdcRegs.ADCSOC2CTL.bit.ACQPS  = ACQPS_Value;\r\n    AdcRegs.ADCSOC3CTL.bit.ACQPS  = ACQPS_Value;\r\n    AdcRegs.ADCSOC4CTL.bit.ACQPS  = ACQPS_Value;\r\n    AdcRegs.ADCSOC5CTL.bit.ACQPS  = ACQPS_Value;\r\n    AdcRegs.ADCSOC6CTL.bit.ACQPS  = ACQPS_Value;\r\n    AdcRegs.ADCSOC7CTL.bit.ACQPS  = ACQPS_Value;\r\n    AdcRegs.ADCSOC8CTL.bit.ACQPS  = ACQPS_Value;\r\n    AdcRegs.ADCSOC9CTL.bit.ACQPS  = ACQPS_Value;\r\n    AdcRegs.ADCSOC10CTL.bit.ACQPS = ACQPS_Value;\r\n    AdcRegs.ADCSOC11CTL.bit.ACQPS = ACQPS_Value;\r\n    AdcRegs.ADCSOC12CTL.bit.ACQPS = ACQPS_Value;\r\n    AdcRegs.ADCSOC13CTL.bit.ACQPS = ACQPS_Value;\r\n    AdcRegs.ADCSOC14CTL.bit.ACQPS = ACQPS_Value;\r\n    AdcRegs.ADCSOC15CTL.bit.ACQPS = ACQPS_Value;\r\n\r\n\r\n    //Enable ping-pong sampling\r\n\r\n    // Enabled ADCINT1 and ADCINT2\r\n    AdcRegs.INTSEL1N2.bit.INT1E = 1;\r\n    AdcRegs.INTSEL1N2.bit.INT2E = 1;\r\n\r\n    // Disable continuous sampling for ADCINT1 and ADCINT2\r\n    AdcRegs.INTSEL1N2.bit.INT1CONT = 0;\r\n    AdcRegs.INTSEL1N2.bit.INT2CONT = 0;\r\n\r\n    AdcRegs.ADCCTL1.bit.INTPULSEPOS = 1;    //ADCINTs trigger at end of conversion\r\n\r\n    // Setup ADCINT1 and ADCINT2 trigger source\r\n    AdcRegs.INTSEL1N2.bit.INT1SEL = 6;      //EOC6 triggers ADCINT1\r\n    AdcRegs.INTSEL1N2.bit.INT2SEL = 14;     //EOC14 triggers ADCINT2\r\n\r\n    // Setup each SOC's ADCINT trigger source\r\n    AdcRegs.ADCINTSOCSEL1.bit.SOC0  = 2;    //ADCINT2 starts SOC0-7\r\n    AdcRegs.ADCINTSOCSEL1.bit.SOC1  = 2;\r\n    AdcRegs.ADCINTSOCSEL1.bit.SOC2  = 2;\r\n    AdcRegs.ADCINTSOCSEL1.bit.SOC3  = 2;\r\n    AdcRegs.ADCINTSOCSEL1.bit.SOC4  = 2;\r\n    AdcRegs.ADCINTSOCSEL1.bit.SOC5  = 2;\r\n    AdcRegs.ADCINTSOCSEL1.bit.SOC6  = 2;\r\n    AdcRegs.ADCINTSOCSEL1.bit.SOC7  = 2;\r\n    AdcRegs.ADCINTSOCSEL2.bit.SOC8  = 1;    //ADCINT1 starts SOC8-15\r\n    AdcRegs.ADCINTSOCSEL2.bit.SOC9  = 1;\r\n    AdcRegs.ADCINTSOCSEL2.bit.SOC10 = 1;\r\n    AdcRegs.ADCINTSOCSEL2.bit.SOC11 = 1;\r\n    AdcRegs.ADCINTSOCSEL2.bit.SOC12 = 1;\r\n    AdcRegs.ADCINTSOCSEL2.bit.SOC13 = 1;\r\n    AdcRegs.ADCINTSOCSEL2.bit.SOC14 = 1;\r\n    AdcRegs.ADCINTSOCSEL2.bit.SOC15 = 1;\r\n\r\n    DELAY_US(ADC_usDELAY);                  // Delay before converting ADC channels\r\n\r\n\r\n    //ADC Conversion\r\n\r\n    AdcRegs.ADCSOCFRC1.all = 0x00FF;  // Force Start SOC0-7 to begin ping-pong sampling\r\n\r\n    while( index < SampleSize ){\r\n\r\n        //Wait for ADCINT1 to trigger, then add ADCRESULT0-7 registers to sum\r\n        while (AdcRegs.ADCINTFLG.bit.ADCINT1 == 0){}\r\n        AdcRegs.ADCINTFLGCLR.bit.ADCINT1 = 1;   //Must clear ADCINT1 flag since INT1CONT = 0\r\n        Sum += AdcResult.ADCRESULT0;\r\n        Sum += AdcResult.ADCRESULT1;\r\n        Sum += AdcResult.ADCRESULT2;\r\n        Sum += AdcResult.ADCRESULT3;\r\n        Sum += AdcResult.ADCRESULT4;\r\n        Sum += AdcResult.ADCRESULT5;\r\n        Sum += AdcResult.ADCRESULT6;\r\n        // Wait for SOC9 conversion to start, which gives time for SOC7 conversion result\r\n        while( AdcRegs.ADCSOCFLG1.bit.SOC9 == 1 ){}\r\n        Sum += AdcResult.ADCRESULT7;\r\n\r\n        //Wait for ADCINT2 to trigger, then add ADCRESULT8-15 registers to sum\r\n        while (AdcRegs.ADCINTFLG.bit.ADCINT2 == 0){}\r\n        AdcRegs.ADCINTFLGCLR.bit.ADCINT2 = 1;   //Must clear ADCINT2 flag since INT2CONT = 0\r\n        Sum += AdcResult.ADCRESULT8;\r\n        Sum += AdcResult.ADCRESULT9;\r\n        Sum += AdcResult.ADCRESULT10;\r\n        Sum += AdcResult.ADCRESULT11;\r\n        Sum += AdcResult.ADCRESULT12;\r\n        Sum += AdcResult.ADCRESULT13;\r\n        Sum += AdcResult.ADCRESULT14;\r\n        // Wait for SOC1 conversion to start, which gives time for SOC15 conversion result\r\n        while( AdcRegs.ADCSOCFLG1.bit.SOC1 == 1 ){}\r\n        Sum += AdcResult.ADCRESULT15;\r\n\r\n        index+=16;\r\n\r\n    } // end data collection\r\n\r\n    //Disable ADCINT1 and ADCINT2 to STOP the ping-pong sampling\r\n    AdcRegs.INTSEL1N2.bit.INT1E = 0;\r\n    AdcRegs.INTSEL1N2.bit.INT2E = 0;\r\n\r\n    while(AdcRegs.ADCSOCFLG1.all != 0){} // Wait for any pending SOCs to complete\r\n\r\n    // Clear any pending interrupts\r\n    AdcRegs.ADCINTFLGCLR.bit.ADCINT1 = 1;\r\n    AdcRegs.ADCINTFLGCLR.bit.ADCINT2 = 1;\r\n    AdcRegs.ADCINTOVFCLR.bit.ADCINT1 = 1;\r\n    AdcRegs.ADCINTOVFCLR.bit.ADCINT2 = 1;\r\n\r\n    //reset RR pointer to 32, so that next SOC is SOC0\r\n    AdcRegs.SOCPRICTL.bit.SOCPRIORITY = 1;\r\n    while( AdcRegs.SOCPRICTL.bit.SOCPRIORITY != 1 );\r\n    AdcRegs.SOCPRICTL.bit.SOCPRIORITY = 0;\r\n    while( AdcRegs.SOCPRICTL.bit.SOCPRIORITY != 0 );\r\n\r\n    Mean = Sum / SampleSize;    //Calculate average ADC sample value\r\n\r\n    return Mean;                //return the average\r\n\r\n}//end AdcConversion\r\n\r\n//===========================================================================\r\n// End of file.\r\n//===========================================================================\r\n"},{"name":"F2806x_CodeStartBranch.asm","type":"other","group":"legacy","path":"C:\\Users\\rodri\\git\\bruno\\mbd-elevator\\matlab\\controller_base_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ti\\controlSUITE\\device_support\\f2806x\\v151\\F2806x_common\\source","tag":"","groupDisplay":"Other files","code":";//###########################################################################\r\n;//\r\n;// FILE:  F2806x_CodeStartBranch.asm\t\r\n;//\r\n;// TITLE: Branch for redirecting code execution after boot. \r\n;//\r\n;// For these examples, code_start is the first code that is executed after\r\n;// exiting the boot ROM code. \r\n;//\r\n;// The codestart section in the linker cmd file is used to physically place\r\n;// this code at the correct memory location.  This section should be placed \r\n;// at the location the BOOT ROM will re-direct the code to.  For example, \r\n;// for boot to FLASH this code will be located at 0x3f7ff6. \r\n;//\r\n;// In addition, the example F2806x projects are setup such that the codegen\r\n;// entry point is also set to the code_start label.  This is done by linker \r\n;// option -e in the project build options.  When the debugger loads the code,\r\n;// it will automatically set the PC to the \"entry point\" address indicated by\r\n;// the -e linker option.  In this case the debugger is simply assigning the PC, \r\n;// it is not the same as a full reset of the device. \r\n;// \r\n;// The compiler may warn that the entry point for the project is other then\r\n;//  _c_init00.  _c_init00 is the C environment setup and is run before \r\n;// main() is entered. The code_start code will re-direct the execution \r\n;// to _c_init00 and thus there is no worry and this warning can be ignored. \r\n;// \r\n;//###########################################################################\r\n;// $TI Release: F2806x C/C++ Header Files and Peripheral Examples V151 $ \r\n;// $Release Date: February  2, 2016 $ \r\n;// $Copyright: Copyright (C) 2011-2016 Texas Instruments Incorporated -\n;//             http://www.ti.com/ ALL RIGHTS RESERVED $\n;//###########################################################################\r\n\r\n***********************************************************************\r\n\r\nWD_DISABLE\t.set\t1\t\t;set to 1 to disable WD, else set to 0\r\n\r\n    .ref _c_int00\r\n    .global code_start\r\n\r\n***********************************************************************\r\n* Function: codestart section\r\n*\r\n* Description: Branch to code starting point\r\n***********************************************************************\r\n\r\n    .sect \"codestart\"\r\n\r\ncode_start:\r\n    .if WD_DISABLE == 1\r\n        LB wd_disable       ;Branch to watchdog disable code\r\n    .else\r\n        LB _c_int00         ;Branch to start of boot.asm in RTS library\r\n    .endif\r\n\r\n;end codestart section\r\n\r\n***********************************************************************\r\n* Function: wd_disable\r\n*\r\n* Description: Disables the watchdog timer\r\n***********************************************************************\r\n    .if WD_DISABLE == 1\r\n\r\n    .text\r\nwd_disable:\r\n    SETC OBJMODE        ;Set OBJMODE for 28x object code\r\n    EALLOW              ;Enable EALLOW protected register access\r\n    MOVZ DP, #7029h>>6  ;Set data page for WDCR register\r\n    MOV @7029h, #0068h  ;Set WDDIS bit in WDCR to disable WD\r\n    EDIS                ;Disable EALLOW protected register access\r\n    LB _c_int00         ;Branch to start of boot.asm in RTS library\r\n\r\n    .endif\r\n\r\n;end wd_disable\r\n\r\n\t.end\r\n\t\r\n;//===========================================================================\r\n;// End of file.\r\n;//===========================================================================\r\n"},{"name":"F2806x_CpuTimers.c","type":"source","group":"legacy","path":"C:\\Users\\rodri\\git\\bruno\\mbd-elevator\\matlab\\controller_base_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ti\\controlSUITE\\device_support\\f2806x\\v151\\F2806x_common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\r\n//\r\n// FILE:\tF2806x_CpuTimers.c\r\n//\r\n// TITLE:\tCPU 32-bit Timers Initialization & Support Functions.\r\n//\r\n// NOTES:\r\n//\r\n//###########################################################################\r\n// $TI Release: F2806x C/C++ Header Files and Peripheral Examples V151 $\r\n// $Release Date: February  2, 2016 $\r\n// $Copyright: Copyright (C) 2011-2016 Texas Instruments Incorporated -\n//             http://www.ti.com/ ALL RIGHTS RESERVED $\n//###########################################################################\r\n\r\n#include \"F2806x_Device.h\"     // Headerfile Include File\r\n#include \"F2806x_Examples.h\"   // Examples Include File\r\n\r\n\r\nstruct CPUTIMER_VARS CpuTimer0;\r\nstruct CPUTIMER_VARS CpuTimer1;\r\nstruct CPUTIMER_VARS CpuTimer2;\r\n\r\n//---------------------------------------------------------------------------\r\n// InitCpuTimers:\r\n//---------------------------------------------------------------------------\r\n// This function initializes all three CPU timers to a known state.\r\n//\r\nvoid InitCpuTimers(void)\r\n{\r\n    // CPU Timer 0\r\n\t// Initialize address pointers to respective timer registers:\r\n\tCpuTimer0.RegsAddr = &CpuTimer0Regs;\r\n\t// Initialize timer period to maximum:\r\n\tCpuTimer0Regs.PRD.all  = 0xFFFFFFFF;\r\n\t// Initialize pre-scale counter to divide by 1 (SYSCLKOUT):\r\n\tCpuTimer0Regs.TPR.all  = 0;\r\n\tCpuTimer0Regs.TPRH.all = 0;\r\n\t// Make sure timer is stopped:\r\n\tCpuTimer0Regs.TCR.bit.TSS = 1;\r\n\t// Reload all counter register with period value:\r\n\tCpuTimer0Regs.TCR.bit.TRB = 1;\r\n\t// Reset interrupt counters:\r\n\t//CpuTimer0.InterruptCount = 0;\r\n\r\n\r\n// Initialize address pointers to respective timer registers:\r\n\tCpuTimer1.RegsAddr = &CpuTimer1Regs;\r\n\tCpuTimer2.RegsAddr = &CpuTimer2Regs;\r\n\t// Initialize timer period to maximum:\r\n\tCpuTimer1Regs.PRD.all  = 0xFFFFFFFF;\r\n\tCpuTimer2Regs.PRD.all  = 0xFFFFFFFF;\r\n    // Initialize pre-scale counter to divide by 1 (SYSCLKOUT):\r\n\tCpuTimer1Regs.TPR.all  = 0;\r\n\tCpuTimer1Regs.TPRH.all = 0;\r\n\tCpuTimer2Regs.TPR.all  = 0;\r\n\tCpuTimer2Regs.TPRH.all = 0;\r\n    // Make sure timers are stopped:\r\n\tCpuTimer1Regs.TCR.bit.TSS = 1;\r\n\tCpuTimer2Regs.TCR.bit.TSS = 1;\r\n\t// Reload all counter register with period value:\r\n\tCpuTimer1Regs.TCR.bit.TRB = 1;\r\n\tCpuTimer2Regs.TCR.bit.TRB = 1;\r\n\t// Reset interrupt counters:\r\n\t//CpuTimer1.InterruptCount = 0;\r\n\t//CpuTimer2.InterruptCount = 0;\r\n\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n// ConfigCpuTimer:\r\n//---------------------------------------------------------------------------\r\n// This function initializes the selected timer to the period specified\r\n// by the \"Freq\" and \"Period\" parameters. The \"Freq\" is entered as \"MHz\"\r\n// and the period in \"uSeconds\". The timer is held in the stopped state\r\n// after configuration.\r\n//\r\nvoid ConfigCpuTimer(struct CPUTIMER_VARS *Timer, float Freq, float Period)\r\n{\r\n\tUint32 \tPeriodInClocks;\r\n\r\n\t// Initialize timer period:\r\n\tTimer->CPUFreqInMHz = Freq;\r\n\tTimer->PeriodInUSec = Period;\r\n\tPeriodInClocks = (long) (Freq * Period);\r\n\tTimer->RegsAddr->PRD.all = PeriodInClocks - 1; // Counter decrements PRD+1 times each period\r\n\r\n\t// Set pre-scale counter to divide by 1 (SYSCLKOUT):\r\n\tTimer->RegsAddr->TPR.all  = 0;\r\n\tTimer->RegsAddr->TPRH.all  = 0;\r\n\r\n\t// Initialize timer control register:\r\n\tTimer->RegsAddr->TCR.bit.TSS = 1;      // 1 = Stop timer, 0 = Start/Restart Timer\r\n\tTimer->RegsAddr->TCR.bit.TRB = 1;      // 1 = reload timer\r\n\tTimer->RegsAddr->TCR.bit.SOFT = 0;\r\n\tTimer->RegsAddr->TCR.bit.FREE = 0;     // Timer Free Run Disabled\r\n\tTimer->RegsAddr->TCR.bit.TIE = 1;      // 0 = Disable/ 1 = Enable Timer Interrupt\r\n\r\n\t// Reset interrupt counter:\r\n\tTimer->InterruptCount = 0;\r\n\r\n}\r\n\r\n//===========================================================================\r\n// End of file.\r\n//===========================================================================\r\n"},{"name":"F2806x_DefaultIsr.c","type":"source","group":"legacy","path":"C:\\Users\\rodri\\git\\bruno\\mbd-elevator\\matlab\\controller_base_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ti\\controlSUITE\\device_support\\f2806x\\v151\\F2806x_common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\r\n//\r\n// FILE:\tF2806x_DefaultIsr.c\r\n//\r\n// TITLE:\tF2806x Device Default Interrupt Service Routines.\r\n//\r\n// This file contains shell ISR routines for the 2803x PIE vector table.\r\n// Typically these shell ISR routines can be used to populate the entire PIE\r\n// vector table during device debug.  In this manner if an interrupt is taken\r\n// during firmware development, there will always be an ISR to catch it.\r\n//\r\n// As development progresses, these ISR routines can be eliminated and replaced\r\n// with the user's own ISR routines for each interrupt.  Since these shell ISRs\r\n// include infinite loops they will typically not be included as-is in the final\r\n// production firmware.\r\n//\r\n//###########################################################################\r\n// $TI Release: F2806x C/C++ Header Files and Peripheral Examples V151 $\r\n// $Release Date: February  2, 2016 $\r\n// $Copyright: Copyright (C) 2011-2016 Texas Instruments Incorporated -\n//             http://www.ti.com/ ALL RIGHTS RESERVED $\n//###########################################################################\r\n\r\n#include \"F2806x_Device.h\"     // F2806x Headerfile Include File\r\n#include \"F2806x_Examples.h\"   // F2806x Examples Include File\r\n\r\n// Connected to INT13 of CPU (use MINT13 mask):\r\n// ISR can be used by the user.\r\n__interrupt void INT13_ISR(void)     // INT13 or CPU-Timer1\n{\r\n  // Insert ISR Code here\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n__interrupt void INT14_ISR(void)     // INT14 or CPU-Timer2\n{\r\n  // Insert ISR Code here\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n__interrupt void DATALOG_ISR(void)   // Datalogging interrupt\n{\r\n   // Insert ISR Code here\r\n\r\n   // Next two lines for debug only to halt the processor here\r\n   // Remove after inserting ISR Code\r\n  __asm (\"      ESTOP0\");\n   for(;;);\r\n}\r\n\r\n__interrupt void RTOSINT_ISR(void)   // RTOS interrupt\n{\r\n  // Insert ISR Code here\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n__interrupt void EMUINT_ISR(void)    // Emulation interrupt\n{\r\n  // Insert ISR Code here\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n__interrupt void NMI_ISR(void)       // Non-maskable interrupt\n{\r\n  // Insert ISR Code here\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n__interrupt void ILLEGAL_ISR(void)   // Illegal operation TRAP\n{\r\n  // Insert ISR Code here\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm(\"          ESTOP0\");\n  for(;;);\r\n\r\n}\r\n\r\n__interrupt void USER1_ISR(void)     // User Defined trap 1\n{\r\n  // Insert ISR Code here\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n\r\n}\r\n\r\n__interrupt void USER2_ISR(void)     // User Defined trap 2\n{\r\n  // Insert ISR Code here\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n\r\n}\r\n\r\n__interrupt void USER3_ISR(void)     // User Defined trap 3\n{\r\n  // Insert ISR Code here\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n__interrupt void USER4_ISR(void)     // User Defined trap 4\n{\r\n  // Insert ISR Code here\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n__interrupt void USER5_ISR(void)     // User Defined trap 5\n{\r\n  // Insert ISR Code here\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n__interrupt void USER6_ISR(void)     // User Defined trap 6\n{\r\n  // Insert ISR Code here\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n__interrupt void USER7_ISR(void)     // User Defined trap 7\n{\r\n  // Insert ISR Code here\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n__interrupt void USER8_ISR(void)     // User Defined trap 8\n{\r\n  // Insert ISR Code here\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n__interrupt void USER9_ISR(void)     // User Defined trap 9\n{\r\n  // Insert ISR Code here\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n__interrupt void USER10_ISR(void)    // User Defined trap 10\n{\r\n  // Insert ISR Code here\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n__interrupt void USER11_ISR(void)    // User Defined trap 11\n{\r\n  // Insert ISR Code here\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n__interrupt void USER12_ISR(void)     // User Defined trap 12\n{\r\n // Insert ISR Code here\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n\r\n}\r\n\r\n// -----------------------------------------------------------\r\n// PIE Group 1 - MUXed into CPU INT1\r\n// -----------------------------------------------------------\r\n// INT1.1\r\n__interrupt void ADCINT1_ISR(void)   // ADC  (Can also be ISR for INT10.1 when enabled)\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n\r\n}\r\n\r\n// INT1.2\r\n__interrupt void ADCINT2_ISR(void)  // ADC  (Can also be ISR for INT10.2 when enabled)\n{\r\n\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n\r\n __asm(\"\t  ESTOP0\");\n  for(;;);\r\n\r\n}\r\n\r\n// INT1.3 - Reserved\r\n\r\n// INT1.4\r\n__interrupt void  XINT1_ISR(void)\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n\r\n}\r\n\r\n// INT1.5\r\n__interrupt void  XINT2_ISR(void)\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n\r\n}\r\n\r\n// INT1.6\r\n__interrupt void  ADCINT9_ISR(void)\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n\r\n}\r\n\r\n// INT1.7\r\n__interrupt void  TINT0_ISR(void)      // CPU-Timer 0\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT1.8\r\n__interrupt void  WAKEINT_ISR(void)    // WD, LOW Power\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// -----------------------------------------------------------\r\n// PIE Group 2 - MUXed into CPU INT2\r\n// -----------------------------------------------------------\r\n\r\n// INT2.1\r\n__interrupt void EPWM1_TZINT_ISR(void)    // EPWM Trip Zone-1\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT2.2\r\n__interrupt void EPWM2_TZINT_ISR(void)    // EPWM Trip Zone-2\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT2.3\r\n__interrupt void EPWM3_TZINT_ISR(void)    // EPWM Trip Zone-3\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT2.4\r\n__interrupt void EPWM4_TZINT_ISR(void)    // EPWM Trip Zone-4\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT2.5\r\n__interrupt void EPWM5_TZINT_ISR(void)    // EPWM Trip Zone-5\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT2.6\r\n__interrupt void EPWM6_TZINT_ISR(void)    // EPWM Trip Zone-6\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT2.7\r\n__interrupt void EPWM7_TZINT_ISR(void)    // EPWM Trip Zone-7\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT2.8\r\n__interrupt void EPWM8_TZINT_ISR(void)    // EPWM Trip Zone-8\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// -----------------------------------------------------------\r\n// PIE Group 3 - MUXed into CPU INT3\r\n// -----------------------------------------------------------\r\n\r\n// INT 3.1\r\n__interrupt void EPWM1_INT_ISR(void)     // EPWM-1\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT3.2\r\n__interrupt void EPWM2_INT_ISR(void)     // EPWM-2\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT3.3\r\n__interrupt void EPWM3_INT_ISR(void)    // EPWM-3\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT3.4\r\n__interrupt void EPWM4_INT_ISR(void)    // EPWM-4\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT3.5\r\n__interrupt void EPWM5_INT_ISR(void)    // EPWM-5\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT3.6\r\n__interrupt void EPWM6_INT_ISR(void)    // EPWM-6\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT3.7\r\n__interrupt void EPWM7_INT_ISR(void)    // EPWM-7\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT3.8\r\n__interrupt void EPWM8_INT_ISR(void)    // EPWM-8\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// -----------------------------------------------------------\r\n// PIE Group 4 - MUXed into CPU INT4\r\n// -----------------------------------------------------------\r\n\r\n// INT 4.1\r\n__interrupt void ECAP1_INT_ISR(void)    // ECAP-1\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT4.2\r\n__interrupt void ECAP2_INT_ISR(void)    // ECAP-2\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT4.3\r\n__interrupt void ECAP3_INT_ISR(void)    // ECAP-3\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT4.4 - Reserved\r\n// INT4.5 - Reserved\r\n// INT4.6 - Reserved\r\n\r\n// INT4.7\r\n__interrupt void HRCAP1_INT_ISR(void)    // HRCAP-1\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT4.8\r\n__interrupt void HRCAP2_INT_ISR(void)    // HRCAP-2\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// -----------------------------------------------------------\r\n// PIE Group 5 - MUXed into CPU INT5\r\n// -----------------------------------------------------------\r\n\r\n// INT 5.1\r\n__interrupt void EQEP1_INT_ISR(void)    // EQEP-1\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP5;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT5.2\r\n__interrupt void EQEP2_INT_ISR(void)    // EQEP-2\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP5;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT5.3 - Reserved\r\n\r\n// INT5.4\r\n__interrupt void HRCAP3_INT_ISR(void)    // HRCAP-3\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP5;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT5.5\r\n__interrupt void HRCAP4_INT_ISR(void)    // HRCAP-4\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP5;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT5.6 - Reserved\r\n// INT5.7 - Reserved\r\n\r\n// INT5.8\r\n__interrupt void USB0_INT_ISR(void)    // USB-0\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP5;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// -----------------------------------------------------------\r\n// PIE Group 6 - MUXed into CPU INT6\r\n// -----------------------------------------------------------\r\n\r\n// INT6.1\r\n__interrupt void SPIRXINTA_ISR(void)    // SPI-A\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT6.2\r\n__interrupt void SPITXINTA_ISR(void)     // SPI-A\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT6.3\r\n__interrupt void SPIRXINTB_ISR(void)    // SPI-B\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT6.4\r\n__interrupt void SPITXINTB_ISR(void)     // SPI-B\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT6.5\r\n__interrupt void MRINTA_ISR(void)     // McBSP-A\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT6.6\r\n__interrupt void MXINTA_ISR(void)     // McBSP-A\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT6.7 - Reserved\r\n// INT6.8 - Reserved\r\n\r\n// -----------------------------------------------------------\r\n// PIE Group 7 - MUXed into CPU INT7\r\n// -----------------------------------------------------------\r\n\r\n// INT7.1\r\n__interrupt void DINTCH1_ISR(void)     // DMA Channel 1\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT7.2\r\n__interrupt void DINTCH2_ISR(void)     // DMA Channel 2\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT7.3\r\n__interrupt void DINTCH3_ISR(void)     // DMA Channel 3\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT7.4\r\n__interrupt void DINTCH4_ISR(void)     // DMA Channel 4\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT7.5\r\n__interrupt void DINTCH5_ISR(void)     // DMA Channel 5\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT7.6\r\n__interrupt void DINTCH6_ISR(void)     // DMA Channel 6\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT7.7 - Reserved\r\n// INT7.8 - Reserved\r\n\r\n// -----------------------------------------------------------\r\n// PIE Group 8 - MUXed into CPU INT8\r\n// -----------------------------------------------------------\r\n\r\n// INT8.1\r\n__interrupt void I2CINT1A_ISR(void)     // I2C-A\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT8.2\r\n__interrupt void I2CINT2A_ISR(void)     // I2C-A\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT8.3 - Reserved\r\n// INT8.4 - Reserved\r\n// INT8.5 - Reserved\r\n// INT8.6 - Reserved\r\n// INT8.7 - Reserved\r\n// INT8.8 - Reserved\r\n\r\n// -----------------------------------------------------------\r\n// PIE Group 9 - MUXed into CPU INT9\r\n// -----------------------------------------------------------\r\n\r\n// INT9.1\r\n__interrupt void SCIRXINTA_ISR(void)     // SCI-A\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n\r\n}\r\n\r\n// INT9.2\r\n__interrupt void SCITXINTA_ISR(void)     // SCI-A\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n\r\n}\r\n\r\n// INT9.3\r\n__interrupt void SCIRXINTB_ISR(void)     // SCI-B\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n\r\n}\r\n\r\n// INT9.4\r\n__interrupt void SCITXINTB_ISR(void)     // SCI-B\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n\r\n}\r\n\r\n// INT9.5\r\n__interrupt void ECAN0INTA_ISR(void)     // ECAN-A\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n\r\n}\r\n\r\n// INT9.6\r\n__interrupt void ECAN1INTA_ISR(void)     // ECAN-A\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n\r\n}\r\n\r\n// INT9.7 - Reserved\r\n// INT9.8 - Reserved\r\n\r\n// -----------------------------------------------------------\r\n// PIE Group 10 - MUXed into CPU INT10\r\n// -----------------------------------------------------------\r\n\r\n// INT10.1 - Reserved or ADCINT1_ISR\r\n// INT10.2 - Reserved or ADCINT2_ISR\r\n\r\n// INT10.3\r\n__interrupt void ADCINT3_ISR(void)    // ADC\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT10.4\r\n__interrupt void ADCINT4_ISR(void)    // ADC\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT10.5\r\n__interrupt void ADCINT5_ISR(void)    // ADC\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT10.6\r\n__interrupt void ADCINT6_ISR(void)    // ADC\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT10.7\r\n__interrupt void ADCINT7_ISR(void)    // ADC\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT10.8\r\n__interrupt void ADCINT8_ISR(void)    // ADC\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n\r\n// -----------------------------------------------------------\r\n// PIE Group 11 - MUXed into CPU INT11\r\n// -----------------------------------------------------------\r\n\r\n// INT11.1\r\n__interrupt void CLA1_INT1_ISR(void)   // MCLA\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n\r\n}\r\n\r\n// INT11.2\r\n__interrupt void CLA1_INT2_ISR(void)  // MCLA\n{\r\n\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n\r\n __asm(\"\t  ESTOP0\");\n  for(;;);\r\n\r\n}\r\n\r\n// INT11.3\r\n__interrupt void CLA1_INT3_ISR(void)    // MCLA\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT11.4\r\n__interrupt void CLA1_INT4_ISR(void)    // MCLA\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT11.5\r\n__interrupt void CLA1_INT5_ISR(void)    // MCLA\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT11.6\r\n__interrupt void CLA1_INT6_ISR(void)    // MCLA\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT11.7\r\n__interrupt void CLA1_INT7_ISR(void)    // MCLA\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// INT11.8\r\n__interrupt void CLA1_INT8_ISR(void)    // MCLA\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n// -----------------------------------------------------------\r\n// PIE Group 12 - MUXed into CPU INT12\r\n// -----------------------------------------------------------\r\n\r\n// INT12.1\r\n__interrupt void XINT3_ISR(void)  // External interrupt 3\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n\r\n}\r\n\r\n// INT12.2 - Reserved\r\n// INT12.3 - Reserved\r\n// INT12.4 - Reserved\r\n// INT12.5 - Reserved\r\n// INT12.6 - Reserved\r\n\r\n// INT12.7\r\n__interrupt void LVF_ISR(void)  // Latched overflow\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n\r\n}\r\n\r\n// INT12.8\r\n__interrupt void LUF_ISR(void)  // Latched underflow\n{\r\n  // Insert ISR Code here\r\n\r\n  // To receive more interrupts from this PIE group, acknowledge this interrupt\r\n  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\r\n\r\n  // Next two lines for debug only to halt the processor here\r\n  // Remove after inserting ISR Code\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n// Catch All Default ISRs:\r\n//\r\n\r\n__interrupt void EMPTY_ISR(void)  // Empty ISR - only does a return.\n{\r\n\r\n}\r\n\r\n__interrupt void PIE_RESERVED(void)  // Reserved space.  For test.\n{\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n__interrupt void rsvd_ISR(void)      // For test\n{\r\n __asm (\"      ESTOP0\");\n  for(;;);\r\n}\r\n\r\n//===========================================================================\r\n// End of file.\r\n//===========================================================================\r\n\r\n"},{"name":"F2806x_Dma.c","type":"source","group":"legacy","path":"C:\\Users\\rodri\\git\\bruno\\mbd-elevator\\matlab\\controller_base_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ti\\controlSUITE\\device_support\\f2806x\\v151\\F2806x_common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\r\n//\r\n// FILE:    F2806x_DMA.c\r\n//\r\n// TITLE:   F2806x Device DMA Initialization & Support Functions.\r\n//\r\n//###########################################################################\r\n// $TI Release: F2806x C/C++ Header Files and Peripheral Examples V151 $\r\n// $Release Date: February  2, 2016 $\r\n// $Copyright: Copyright (C) 2011-2016 Texas Instruments Incorporated -\n//             http://www.ti.com/ ALL RIGHTS RESERVED $\n//###########################################################################\r\n\r\n#include \"F2806x_Device.h\"     // Headerfile Include File\r\n#include \"F2806x_Examples.h\"   // Examples Include File\r\n\r\n// This function initializes the DMA to a known state.\r\n//\r\nvoid DMAInitialize(void)\r\n{\r\n    EALLOW;\r\n\r\n    // Perform a hard reset on DMA\r\n    DmaRegs.DMACTRL.bit.HARDRESET = 1;\r\n   __asm (\" nop\"); // one NOP required after HARDRESET\n\r\n    // Allow DMA to run free on emulation suspend\r\n    DmaRegs.DEBUGCTRL.bit.FREE = 1;\r\n\r\n    EDIS;\r\n}\r\n\r\n\r\nvoid DMACH1AddrConfig(volatile Uint16 *DMA_Dest,volatile Uint16 *DMA_Source)\r\n{\r\n    EALLOW;\r\n    // Set up SOURCE address:\r\n    DmaRegs.CH1.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source;   // Point to beginning of source buffer\r\n    DmaRegs.CH1.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\r\n\r\n    // Set up DESTINATION address:\r\n    DmaRegs.CH1.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;     // Point to beginning of destination buffer\r\n    DmaRegs.CH1.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\r\n\r\n\r\n    EDIS;\r\n}\r\n\r\nvoid DMACH1BurstConfig(Uint16 bsize, int16 srcbstep, int16 desbstep)\r\n{\r\n    EALLOW;\r\n\r\n    // Set up BURST registers:\r\n    DmaRegs.CH1.BURST_SIZE.all = bsize;                 // Number of words(X-1) x-ferred in a burst\r\n    DmaRegs.CH1.SRC_BURST_STEP = srcbstep;              // Increment source addr between each word x-ferred\r\n    DmaRegs.CH1.DST_BURST_STEP = desbstep;              // Increment dest addr between each word x-ferred\r\n\r\n\r\n    EDIS;\r\n}\r\n\r\nvoid DMACH1TransferConfig(Uint16 tsize, int16 srctstep, int16 deststep)\r\n{\r\n    EALLOW;\r\n\r\n    // Set up TRANSFER registers:\r\n    DmaRegs.CH1.TRANSFER_SIZE = tsize;                  // Number of bursts per transfer, DMA interrupt will occur after completed transfer\r\n    DmaRegs.CH1.SRC_TRANSFER_STEP = srctstep;           // TRANSFER_STEP is ignored when WRAP occurs\r\n    DmaRegs.CH1.DST_TRANSFER_STEP = deststep;           // TRANSFER_STEP is ignored when WRAP occurs\r\n\r\n    EDIS;\r\n}\r\n\r\nvoid DMACH1WrapConfig(Uint16 srcwsize, int16 srcwstep, Uint16 deswsize, int16 deswstep)\r\n{\r\n    EALLOW;\r\n\r\n        // Set up WRAP registers:\r\n    DmaRegs.CH1.SRC_WRAP_SIZE = srcwsize;               // Wrap source address after N bursts\r\n    DmaRegs.CH1.SRC_WRAP_STEP = srcwstep;               // Step for source wrap\r\n\r\n    DmaRegs.CH1.DST_WRAP_SIZE = deswsize;               // Wrap destination address after N bursts\r\n    DmaRegs.CH1.DST_WRAP_STEP = deswstep;               // Step for destination wrap\r\n\r\n    EDIS;\r\n}\r\n\r\n\r\nvoid DMACH1ModeConfig(Uint16 persel, Uint16 perinte, Uint16 oneshot, Uint16 cont, Uint16 synce, Uint16 syncsel, Uint16 ovrinte, Uint16 datasize, Uint16 chintmode, Uint16 chinte)\r\n{\r\n    EALLOW;\r\n\r\n    // Set up MODE Register:\r\n    DmaRegs.CH1.MODE.bit.PERINTSEL = persel;        // Passed DMA channel as peripheral interrupt source\r\n    DmaRegs.CH1.MODE.bit.PERINTE = perinte;         // Peripheral interrupt enable\r\n    DmaRegs.CH1.MODE.bit.ONESHOT = oneshot;         // Oneshot enable\r\n    DmaRegs.CH1.MODE.bit.CONTINUOUS = cont;         // Continous enable\r\n\r\n\r\n    DmaRegs.CH1.MODE.bit.OVRINTE = ovrinte;         // Enable/disable the overflow interrupt\r\n    DmaRegs.CH1.MODE.bit.DATASIZE = datasize;       // 16-bit/32-bit data size transfers\r\n    DmaRegs.CH1.MODE.bit.CHINTMODE = chintmode;     // Generate interrupt to CPU at beginning/end of transfer\r\n    DmaRegs.CH1.MODE.bit.CHINTE = chinte;           // Channel Interrupt to CPU enable\r\n\r\n    // Clear any spurious flags:\r\n    DmaRegs.CH1.CONTROL.bit.PERINTCLR = 1;          // Clear any spurious interrupt flags\r\n\r\n    DmaRegs.CH1.CONTROL.bit.ERRCLR = 1;             // Clear any spurious sync error flags\r\n\r\n    // Initialize PIE vector for CPU interrupt:\r\n    PieCtrlRegs.PIEIER7.bit.INTx1 = 1;              // Enable DMA CH1 interrupt in PIE\r\n\r\n    EDIS;\r\n}\r\n\r\n// This function starts DMA Channel 1.\r\nvoid StartDMACH1(void)\r\n{\r\n    EALLOW;\r\n    DmaRegs.CH1.CONTROL.bit.RUN = 1;\r\n    EDIS;\r\n}\r\n\r\nvoid DMACH2AddrConfig(volatile Uint16 *DMA_Dest,volatile Uint16 *DMA_Source)\r\n{\r\n    EALLOW;\r\n\r\n    // Set up SOURCE address:\r\n    DmaRegs.CH2.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source;   // Point to beginning of source buffer\r\n    DmaRegs.CH2.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\r\n\r\n    // Set up DESTINATION address:\r\n    DmaRegs.CH2.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;     // Point to beginning of destination buffer\r\n    DmaRegs.CH2.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\r\n\r\n\r\n    EDIS;\r\n}\r\n\r\nvoid DMACH2BurstConfig(Uint16 bsize, int16 srcbstep, int16 desbstep)\r\n{\r\n    EALLOW;\r\n\r\n    // Set up BURST registers:\r\n    DmaRegs.CH2.BURST_SIZE.all = bsize;                 // Number of words(X-1) x-ferred in a burst\r\n    DmaRegs.CH2.SRC_BURST_STEP = srcbstep;              // Increment source addr between each word x-ferred\r\n    DmaRegs.CH2.DST_BURST_STEP = desbstep;              // Increment dest addr between each word x-ferred\r\n\r\n\r\n    EDIS;\r\n}\r\n\r\nvoid DMACH2TransferConfig(Uint16 tsize, int16 srctstep, int16 deststep)\r\n{\r\n    EALLOW;\r\n\r\n        // Set up TRANSFER registers:\r\n    DmaRegs.CH2.TRANSFER_SIZE = tsize;                  // Number of bursts per transfer, DMA interrupt will occur after completed transfer\r\n    DmaRegs.CH2.SRC_TRANSFER_STEP = srctstep;           // TRANSFER_STEP is ignored when WRAP occurs\r\n    DmaRegs.CH2.DST_TRANSFER_STEP = deststep;           // TRANSFER_STEP is ignored when WRAP occurs\r\n\r\n    EDIS;\r\n}\r\n\r\nvoid DMACH2WrapConfig(Uint16 srcwsize, int16 srcwstep, Uint16 deswsize, int16 deswstep)\r\n{\r\n    EALLOW;\r\n\r\n        // Set up WRAP registers:\r\n    DmaRegs.CH2.SRC_WRAP_SIZE = srcwsize;               // Wrap source address after N bursts\r\n    DmaRegs.CH2.SRC_WRAP_STEP = srcwstep;               // Step for source wrap\r\n\r\n    DmaRegs.CH2.DST_WRAP_SIZE = deswsize;               // Wrap destination address after N bursts\r\n    DmaRegs.CH2.DST_WRAP_STEP = deswstep;               // Step for destination wrap\r\n\r\n    EDIS;\r\n}\r\n\r\n\r\nvoid DMACH2ModeConfig(Uint16 persel, Uint16 perinte, Uint16 oneshot, Uint16 cont, Uint16 synce, Uint16 syncsel, Uint16 ovrinte, Uint16 datasize, Uint16 chintmode, Uint16 chinte)\r\n{\r\n    EALLOW;\r\n\r\n        // Set up MODE Register:\r\n    DmaRegs.CH2.MODE.bit.PERINTSEL = persel;        // Passed DMA channel as peripheral interrupt source\r\n    DmaRegs.CH2.MODE.bit.PERINTE = perinte;         // Peripheral interrupt enable\r\n    DmaRegs.CH2.MODE.bit.ONESHOT = oneshot;         // Oneshot enable\r\n    DmaRegs.CH2.MODE.bit.CONTINUOUS = cont;         // Continous enable\r\n\r\n\r\n    DmaRegs.CH2.MODE.bit.OVRINTE = ovrinte;         // Enable/disable the overflow interrupt\r\n    DmaRegs.CH2.MODE.bit.DATASIZE = datasize;       // 16-bit/32-bit data size transfers\r\n    DmaRegs.CH2.MODE.bit.CHINTMODE = chintmode;     // Generate interrupt to CPU at beginning/end of transfer\r\n    DmaRegs.CH2.MODE.bit.CHINTE = chinte;           // Channel Interrupt to CPU enable\r\n\r\n    // Clear any spurious flags:\r\n    DmaRegs.CH2.CONTROL.bit.PERINTCLR = 1;          // Clear any spurious interrupt flags\r\n\r\n    DmaRegs.CH2.CONTROL.bit.ERRCLR = 1;             // Clear any spurious sync error flags\r\n\r\n    // Initialize PIE vector for CPU interrupt:\r\n    PieCtrlRegs.PIEIER7.bit.INTx2 = 1;              // Enable DMA CH2 interrupt in PIE\r\n\r\n    EDIS;\r\n}\r\n\r\n\r\n\r\n// This function starts DMA Channel 2.\r\nvoid StartDMACH2(void)\r\n{\r\n    EALLOW;\r\n    DmaRegs.CH2.CONTROL.bit.RUN = 1;\r\n    EDIS;\r\n}\r\n\r\n\r\n\r\nvoid DMACH3AddrConfig(volatile Uint16 *DMA_Dest,volatile Uint16 *DMA_Source)\r\n{\r\n    EALLOW;\r\n\r\n    // Set up SOURCE address:\r\n    DmaRegs.CH3.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source;   // Point to beginning of source buffer\r\n    DmaRegs.CH3.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\r\n\r\n    // Set up DESTINATION address:\r\n    DmaRegs.CH3.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;     // Point to beginning of destination buffer\r\n    DmaRegs.CH3.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\r\n\r\n\r\n    EDIS;\r\n}\r\n\r\nvoid DMACH3BurstConfig(Uint16 bsize, int16 srcbstep, int16 desbstep)\r\n{\r\n    EALLOW;\r\n\r\n    // Set up BURST registers:\r\n    DmaRegs.CH3.BURST_SIZE.all = bsize;                 // Number of words(X-1) x-ferred in a burst\r\n    DmaRegs.CH3.SRC_BURST_STEP = srcbstep;              // Increment source addr between each word x-ferred\r\n    DmaRegs.CH3.DST_BURST_STEP = desbstep;              // Increment dest addr between each word x-ferred\r\n\r\n\r\n    EDIS;\r\n}\r\n\r\nvoid DMACH3TransferConfig(Uint16 tsize, int16 srctstep, int16 deststep)\r\n{\r\n    EALLOW;\r\n\r\n        // Set up TRANSFER registers:\r\n    DmaRegs.CH3.TRANSFER_SIZE = tsize;                  // Number of bursts per transfer, DMA interrupt will occur after completed transfer\r\n    DmaRegs.CH3.SRC_TRANSFER_STEP = srctstep;           // TRANSFER_STEP is ignored when WRAP occurs\r\n    DmaRegs.CH3.DST_TRANSFER_STEP = deststep;           // TRANSFER_STEP is ignored when WRAP occurs\r\n\r\n    EDIS;\r\n}\r\n\r\nvoid DMACH3WrapConfig(Uint16 srcwsize, int16 srcwstep, Uint16 deswsize, int16 deswstep)\r\n{\r\n    EALLOW;\r\n\r\n            // Set up WRAP registers:\r\n    DmaRegs.CH3.SRC_WRAP_SIZE = srcwsize;               // Wrap source address after N bursts\r\n    DmaRegs.CH3.SRC_WRAP_STEP = srcwstep;               // Step for source wrap\r\n\r\n    DmaRegs.CH3.DST_WRAP_SIZE = deswsize;               // Wrap destination address after N bursts\r\n    DmaRegs.CH3.DST_WRAP_STEP = deswstep;               // Step for destination wrap\r\n\r\n    EDIS;\r\n}\r\n\r\n\r\nvoid DMACH3ModeConfig(Uint16 persel, Uint16 perinte, Uint16 oneshot, Uint16 cont, Uint16 synce, Uint16 syncsel, Uint16 ovrinte, Uint16 datasize, Uint16 chintmode, Uint16 chinte)\r\n{\r\n    EALLOW;\r\n\r\n    // Set up MODE Register:\r\n    DmaRegs.CH3.MODE.bit.PERINTSEL = persel;        // Passed DMA channel as peripheral interrupt source\r\n    DmaRegs.CH3.MODE.bit.PERINTE = perinte;         // Peripheral interrupt enable\r\n    DmaRegs.CH3.MODE.bit.ONESHOT = oneshot;         // Oneshot enable\r\n    DmaRegs.CH3.MODE.bit.CONTINUOUS = cont;         // Continous enable\r\n\r\n\r\n    DmaRegs.CH3.MODE.bit.OVRINTE = ovrinte;         // Enable/disable the overflow interrupt\r\n    DmaRegs.CH3.MODE.bit.DATASIZE = datasize;       // 16-bit/32-bit data size transfers\r\n    DmaRegs.CH3.MODE.bit.CHINTMODE = chintmode;     // Generate interrupt to CPU at beginning/end of transfer\r\n    DmaRegs.CH3.MODE.bit.CHINTE = chinte;           // Channel Interrupt to CPU enable\r\n\r\n    // Clear any spurious flags:\r\n    DmaRegs.CH3.CONTROL.bit.PERINTCLR = 1;          // Clear any spurious interrupt flags\r\n\r\n    DmaRegs.CH3.CONTROL.bit.ERRCLR = 1;             // Clear any spurious sync error flags\r\n\r\n    // Initialize PIE vector for CPU interrupt:\r\n    PieCtrlRegs.PIEIER7.bit.INTx3 = 1;              // Enable DMA CH3 interrupt in PIE\r\n\r\n    EDIS;\r\n}\r\n\r\n// This function starts DMA Channel 3.\r\nvoid StartDMACH3(void)\r\n{\r\n    EALLOW;\r\n    DmaRegs.CH3.CONTROL.bit.RUN = 1;\r\n    EDIS;\r\n}\r\n\r\n\r\nvoid DMACH4AddrConfig(volatile Uint16 *DMA_Dest,volatile Uint16 *DMA_Source)\r\n{\r\n    EALLOW;\r\n\r\n    // Set up SOURCE address:\r\n    DmaRegs.CH4.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source;   // Point to beginning of source buffer\r\n    DmaRegs.CH4.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\r\n\r\n    // Set up DESTINATION address:\r\n    DmaRegs.CH4.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;     // Point to beginning of destination buffer\r\n    DmaRegs.CH4.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\r\n\r\n\r\n    EDIS;\r\n}\r\n\r\nvoid DMACH4BurstConfig(Uint16 bsize, int16 srcbstep, int16 desbstep)\r\n{\r\n    EALLOW;\r\n\r\n    // Set up BURST registers:\r\n    DmaRegs.CH4.BURST_SIZE.all = bsize;                 // Number of words(X-1) x-ferred in a burst\r\n    DmaRegs.CH4.SRC_BURST_STEP = srcbstep;              // Increment source addr between each word x-ferred\r\n    DmaRegs.CH4.DST_BURST_STEP = desbstep;              // Increment dest addr between each word x-ferred\r\n\r\n\r\n    EDIS;\r\n}\r\n\r\nvoid DMACH4TransferConfig(Uint16 tsize, int16 srctstep, int16 deststep)\r\n{\r\n    EALLOW;\r\n\r\n    // Set up TRANSFER registers:\r\n    DmaRegs.CH4.TRANSFER_SIZE = tsize;                  // Number of bursts per transfer, DMA interrupt will occur after completed transfer\r\n    DmaRegs.CH4.SRC_TRANSFER_STEP = srctstep;           // TRANSFER_STEP is ignored when WRAP occurs\r\n    DmaRegs.CH4.DST_TRANSFER_STEP = deststep;           // TRANSFER_STEP is ignored when WRAP occurs\r\n\r\n    EDIS;\r\n}\r\n\r\nvoid DMACH4WrapConfig(Uint16 srcwsize, int16 srcwstep, Uint16 deswsize, int16 deswstep)\r\n{\r\n    EALLOW;\r\n\r\n        // Set up WRAP registers:\r\n    DmaRegs.CH4.SRC_WRAP_SIZE = srcwsize;               // Wrap source address after N bursts\r\n    DmaRegs.CH4.SRC_WRAP_STEP = srcwstep;               // Step for source wrap\r\n\r\n    DmaRegs.CH4.DST_WRAP_SIZE = deswsize;               // Wrap destination address after N bursts\r\n    DmaRegs.CH4.DST_WRAP_STEP = deswstep;               // Step for destination wrap\r\n\r\n    EDIS;\r\n}\r\n\r\n\r\nvoid DMACH4ModeConfig(Uint16 persel, Uint16 perinte, Uint16 oneshot, Uint16 cont, Uint16 synce, Uint16 syncsel, Uint16 ovrinte, Uint16 datasize, Uint16 chintmode, Uint16 chinte)\r\n{\r\n    EALLOW;\r\n\r\n        // Set up MODE Register:\r\n    DmaRegs.CH4.MODE.bit.PERINTSEL = persel;        // Passed DMA channel as peripheral interrupt source\r\n    DmaRegs.CH4.MODE.bit.PERINTE = perinte;         // Peripheral interrupt enable\r\n    DmaRegs.CH4.MODE.bit.ONESHOT = oneshot;         // Oneshot enable\r\n    DmaRegs.CH4.MODE.bit.CONTINUOUS = cont;         // Continous enable\r\n\r\n\r\n    DmaRegs.CH4.MODE.bit.OVRINTE = ovrinte;         // Enable/disable the overflow interrupt\r\n    DmaRegs.CH4.MODE.bit.DATASIZE = datasize;       // 16-bit/32-bit data size transfers\r\n    DmaRegs.CH4.MODE.bit.CHINTMODE = chintmode;     // Generate interrupt to CPU at beginning/end of transfer\r\n    DmaRegs.CH4.MODE.bit.CHINTE = chinte;           // Channel Interrupt to CPU enable\r\n\r\n    // Clear any spurious flags:\r\n    DmaRegs.CH4.CONTROL.bit.PERINTCLR = 1;          // Clear any spurious interrupt flags\r\n\r\n    DmaRegs.CH4.CONTROL.bit.ERRCLR = 1;             // Clear any spurious sync error flags\r\n\r\n    // Initialize PIE vector for CPU interrupt:\r\n    PieCtrlRegs.PIEIER7.bit.INTx4 = 1;              // Enable DMA CH4 interrupt in PIE\r\n\r\n    EDIS;\r\n}\r\n\r\n\r\n// This function starts DMA Channel 4.\r\nvoid StartDMACH4(void)\r\n{\r\n    EALLOW;\r\n    DmaRegs.CH4.CONTROL.bit.RUN = 1;\r\n    EDIS;\r\n}\r\n\r\n\r\nvoid DMACH5AddrConfig(volatile Uint16 *DMA_Dest,volatile Uint16 *DMA_Source)\r\n{\r\n    EALLOW;\r\n\r\n    // Set up SOURCE address:\r\n    DmaRegs.CH5.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source;   // Point to beginning of source buffer\r\n    DmaRegs.CH5.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\r\n\r\n    // Set up DESTINATION address:\r\n    DmaRegs.CH5.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;     // Point to beginning of destination buffer\r\n    DmaRegs.CH5.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\r\n\r\n\r\n    EDIS;\r\n}\r\n\r\nvoid DMACH5BurstConfig(Uint16 bsize, int16 srcbstep, int16 desbstep)\r\n{\r\n    EALLOW;\r\n\r\n\r\n    // Set up BURST registers:\r\n    DmaRegs.CH5.BURST_SIZE.all = bsize;                 // Number of words(X-1) x-ferred in a burst\r\n    DmaRegs.CH5.SRC_BURST_STEP = srcbstep;              // Increment source addr between each word x-ferred\r\n    DmaRegs.CH5.DST_BURST_STEP = desbstep;              // Increment dest addr between each word x-ferred\r\n\r\n    EDIS;\r\n}\r\n\r\nvoid DMACH5TransferConfig(Uint16 tsize, int16 srctstep, int16 deststep)\r\n{\r\n    EALLOW;\r\n\r\n\r\n        // Set up TRANSFER registers:\r\n    DmaRegs.CH5.TRANSFER_SIZE = tsize;                  // Number of bursts per transfer, DMA interrupt will occur after completed transfer\r\n    DmaRegs.CH5.SRC_TRANSFER_STEP = srctstep;           // TRANSFER_STEP is ignored when WRAP occurs\r\n    DmaRegs.CH5.DST_TRANSFER_STEP = deststep;           // TRANSFER_STEP is ignored when WRAP occurs\r\n\r\n    EDIS;\r\n}\r\n\r\nvoid DMACH5WrapConfig(Uint16 srcwsize, int16 srcwstep, Uint16 deswsize, int16 deswstep)\r\n{\r\n    EALLOW;\r\n\r\n\r\n        // Set up WRAP registers:\r\n    DmaRegs.CH5.SRC_WRAP_SIZE = srcwsize;               // Wrap source address after N bursts\r\n    DmaRegs.CH5.SRC_WRAP_STEP = srcwstep;               // Step for source wrap\r\n\r\n    DmaRegs.CH5.DST_WRAP_SIZE = deswsize;               // Wrap destination address after N bursts\r\n    DmaRegs.CH5.DST_WRAP_STEP = deswstep;               // Step for destination wrap\r\n\r\n    EDIS;\r\n}\r\n\r\n\r\nvoid DMACH5ModeConfig(Uint16 persel, Uint16 perinte, Uint16 oneshot, Uint16 cont, Uint16 synce, Uint16 syncsel, Uint16 ovrinte, Uint16 datasize, Uint16 chintmode, Uint16 chinte)\r\n{\r\n    EALLOW;\r\n\r\n        // Set up MODE Register:\r\n    DmaRegs.CH5.MODE.bit.PERINTSEL = persel;        // Passed DMA channel as peripheral interrupt source\r\n    DmaRegs.CH5.MODE.bit.PERINTE = perinte;         // Peripheral interrupt enable\r\n    DmaRegs.CH5.MODE.bit.ONESHOT = oneshot;         // Oneshot enable\r\n    DmaRegs.CH5.MODE.bit.CONTINUOUS = cont;         // Continous enable\r\n\r\n\r\n    DmaRegs.CH5.MODE.bit.OVRINTE = ovrinte;         // Enable/disable the overflow interrupt\r\n    DmaRegs.CH5.MODE.bit.DATASIZE = datasize;       // 16-bit/32-bit data size transfers\r\n    DmaRegs.CH5.MODE.bit.CHINTMODE = chintmode;     // Generate interrupt to CPU at beginning/end of transfer\r\n    DmaRegs.CH5.MODE.bit.CHINTE = chinte;           // Channel Interrupt to CPU enable\r\n\r\n    // Clear any spurious flags:\r\n    DmaRegs.CH5.CONTROL.bit.PERINTCLR = 1;          // Clear any spurious interrupt flags\r\n\r\n    DmaRegs.CH5.CONTROL.bit.ERRCLR = 1;             // Clear any spurious sync error flags\r\n\r\n    // Initialize PIE vector for CPU interrupt:\r\n    PieCtrlRegs.PIEIER7.bit.INTx5 = 1;              // Enable DMA CH5 interrupt in PIE\r\n\r\n    EDIS;\r\n}\r\n\r\n// This function starts DMA Channel 5.\r\nvoid StartDMACH5(void)\r\n{\r\n    EALLOW;\r\n    DmaRegs.CH5.CONTROL.bit.RUN = 1;\r\n    EDIS;\r\n}\r\n\r\n\r\n\r\nvoid DMACH6AddrConfig(volatile Uint16 *DMA_Dest,volatile Uint16 *DMA_Source)\r\n{\r\n    EALLOW;\r\n\r\n    // Set up SOURCE address:\r\n    DmaRegs.CH6.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source;   // Point to beginning of source buffer\r\n    DmaRegs.CH6.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\r\n\r\n    // Set up DESTINATION address:\r\n    DmaRegs.CH6.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;     // Point to beginning of destination buffer\r\n    DmaRegs.CH6.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\r\n\r\n\r\n    EDIS;\r\n}\r\n\r\nvoid DMACH6BurstConfig(Uint16 bsize,Uint16 srcbstep, int16 desbstep)\r\n{\r\n    EALLOW;\r\n\r\n    // Set up BURST registers:\r\n    DmaRegs.CH6.BURST_SIZE.all = bsize;                 // Number of words(X-1) x-ferred in a burst\r\n    DmaRegs.CH6.SRC_BURST_STEP = srcbstep;                  // Increment source addr between each word x-ferred\r\n    DmaRegs.CH6.DST_BURST_STEP = desbstep;                // Increment dest addr between each word x-ferred\r\n\r\n\r\n    EDIS;\r\n}\r\n\r\nvoid DMACH6TransferConfig(Uint16 tsize, int16 srctstep, int16 deststep)\r\n{\r\n    EALLOW;\r\n\r\n    // Set up TRANSFER registers:\r\n    DmaRegs.CH6.TRANSFER_SIZE = tsize;                  // Number of bursts per transfer, DMA interrupt will occur after completed transfer\r\n    DmaRegs.CH6.SRC_TRANSFER_STEP = srctstep;           // TRANSFER_STEP is ignored when WRAP occurs\r\n    DmaRegs.CH6.DST_TRANSFER_STEP = deststep;           // TRANSFER_STEP is ignored when WRAP occurs\r\n\r\n    EDIS;\r\n}\r\n\r\nvoid DMACH6WrapConfig(Uint16 srcwsize, int16 srcwstep, Uint16 deswsize, int16 deswstep)\r\n{\r\n    EALLOW;\r\n\r\n        // Set up WRAP registers:\r\n    DmaRegs.CH6.SRC_WRAP_SIZE = srcwsize;               // Wrap source address after N bursts\r\n    DmaRegs.CH6.SRC_WRAP_STEP = srcwstep;               // Step for source wrap\r\n\r\n    DmaRegs.CH6.DST_WRAP_SIZE = deswsize;               // Wrap destination address after N bursts\r\n    DmaRegs.CH6.DST_WRAP_STEP = deswstep;               // Step for destination wrap\r\n\r\n    EDIS;\r\n}\r\n\r\n\r\nvoid DMACH6ModeConfig(Uint16 persel, Uint16 perinte, Uint16 oneshot, Uint16 cont, Uint16 synce, Uint16 syncsel, Uint16 ovrinte, Uint16 datasize, Uint16 chintmode, Uint16 chinte)\r\n{\r\n    EALLOW;\r\n\r\n        // Set up MODE Register:\r\n    DmaRegs.CH6.MODE.bit.PERINTSEL = persel;        // Passed DMA channel as peripheral interrupt source\r\n    DmaRegs.CH6.MODE.bit.PERINTE = perinte;         // Peripheral interrupt enable\r\n    DmaRegs.CH6.MODE.bit.ONESHOT = oneshot;         // Oneshot enable\r\n    DmaRegs.CH6.MODE.bit.CONTINUOUS = cont;         // Continous enable\r\n\r\n\r\n    DmaRegs.CH6.MODE.bit.OVRINTE = ovrinte;         // Enable/disable the overflow interrupt\r\n    DmaRegs.CH6.MODE.bit.DATASIZE = datasize;       // 16-bit/32-bit data size transfers\r\n    DmaRegs.CH6.MODE.bit.CHINTMODE = chintmode;     // Generate interrupt to CPU at beginning/end of transfer\r\n    DmaRegs.CH6.MODE.bit.CHINTE = chinte;           // Channel Interrupt to CPU enable\r\n\r\n    // Clear any spurious flags:\r\n    DmaRegs.CH6.CONTROL.bit.PERINTCLR = 1;          // Clear any spurious interrupt flags\r\n\r\n    DmaRegs.CH6.CONTROL.bit.ERRCLR = 1;             // Clear any spurious sync error flags\r\n\r\n    // Initialize PIE vector for CPU interrupt:\r\n    PieCtrlRegs.PIEIER7.bit.INTx6 = 1;              // Enable DMA CH6 interrupt in PIE\r\n\r\n    EDIS;\r\n}\r\n\r\n// This function starts DMA Channel 6.\r\nvoid StartDMACH6(void)\r\n{\r\n    EALLOW;\r\n    DmaRegs.CH6.CONTROL.bit.RUN = 1;\r\n    EDIS;\r\n}\r\n\r\n//===========================================================================\r\n// No more.\r\n//===========================================================================\r\n"},{"name":"F2806x_GlobalVariableDefs.c","type":"source","group":"legacy","path":"C:\\Users\\rodri\\git\\bruno\\mbd-elevator\\matlab\\controller_base_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ti\\controlSUITE\\device_support\\f2806x\\v151\\F2806x_headers\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\r\n//\r\n// FILE:    F2806x_GlobalVariableDefs.c\r\n//\r\n// TITLE:   F2806x Global Variables and Data Section Pragmas.\r\n//\r\n//###########################################################################\r\n// $TI Release: F2806x C/C++ Header Files and Peripheral Examples V151 $\r\n// $Release Date: February  2, 2016 $\r\n// $Copyright: Copyright (C) 2011-2016 Texas Instruments Incorporated -\n//             http://www.ti.com/ ALL RIGHTS RESERVED $\n//###########################################################################\r\n\r\n#include \"F2806x_Device.h\"     // F2806x Headerfile Include File\r\n\r\n//---------------------------------------------------------------------------\r\n// Define Global Peripheral Variables:\r\n//\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"AdcRegsFile\")\r\n#else\r\n#pragma DATA_SECTION(AdcRegs,\"AdcRegsFile\");\r\n#endif\r\nvolatile struct ADC_REGS AdcRegs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"AdcResultFile\")\r\n#else\r\n#pragma DATA_SECTION(AdcResult,\"AdcResultFile\");\r\n#endif\r\nvolatile struct ADC_RESULT_REGS AdcResult;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"Cla1RegsFile\")\r\n#else\r\n#pragma DATA_SECTION(Cla1Regs,\"Cla1RegsFile\");\r\n#endif\r\nvolatile struct CLA_REGS Cla1Regs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"Comp1RegsFile\")\r\n#else\r\n#pragma DATA_SECTION(Comp1Regs,\"Comp1RegsFile\");\r\n#endif\r\nvolatile struct COMP_REGS Comp1Regs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"Comp2RegsFile\")\r\n#else\r\n#pragma DATA_SECTION(Comp2Regs,\"Comp2RegsFile\");\r\n#endif\r\nvolatile struct COMP_REGS Comp2Regs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"Comp3RegsFile\")\r\n#else\r\n#pragma DATA_SECTION(Comp3Regs,\"Comp3RegsFile\");\r\n#endif\r\nvolatile struct COMP_REGS Comp3Regs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"CpuTimer0RegsFile\")\r\n#else\r\n#pragma DATA_SECTION(CpuTimer0Regs,\"CpuTimer0RegsFile\");\r\n#endif\r\nvolatile struct CPUTIMER_REGS CpuTimer0Regs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"CpuTimer1RegsFile\")\r\n#else\r\n#pragma DATA_SECTION(CpuTimer1Regs,\"CpuTimer1RegsFile\");\r\n#endif\r\nvolatile struct CPUTIMER_REGS CpuTimer1Regs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"CpuTimer2RegsFile\")\r\n#else\r\n#pragma DATA_SECTION(CpuTimer2Regs,\"CpuTimer2RegsFile\");\r\n#endif\r\nvolatile struct CPUTIMER_REGS CpuTimer2Regs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"CsmPwlFile\")\r\n#else\r\n#pragma DATA_SECTION(CsmPwl,\"CsmPwlFile\");\r\n#endif\r\nvolatile struct CSM_PWL CsmPwl;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"CsmRegsFile\")\r\n#else\r\n#pragma DATA_SECTION(CsmRegs,\"CsmRegsFile\");\r\n#endif\r\nvolatile struct CSM_REGS CsmRegs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"DevEmuRegsFile\")\r\n#else\r\n#pragma DATA_SECTION(DevEmuRegs,\"DevEmuRegsFile\");\r\n#endif\r\nvolatile struct DEV_EMU_REGS DevEmuRegs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"DmaRegsFile\")\r\n#else\r\n#pragma DATA_SECTION(DmaRegs,\"DmaRegsFile\");\r\n#endif\r\nvolatile struct DMA_REGS DmaRegs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"ECanaRegsFile\")\r\n#else\r\n#pragma DATA_SECTION(ECanaRegs,\"ECanaRegsFile\");\r\n#endif\r\nvolatile struct ECAN_REGS ECanaRegs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"ECanaMboxesFile\")\r\n#else\r\n#pragma DATA_SECTION(ECanaMboxes,\"ECanaMboxesFile\");\r\n#endif\r\nvolatile struct ECAN_MBOXES ECanaMboxes;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"ECanaLAMRegsFile\")\r\n#else\r\n#pragma DATA_SECTION(ECanaLAMRegs,\"ECanaLAMRegsFile\");\r\n#endif\r\nvolatile struct LAM_REGS ECanaLAMRegs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"ECanaMOTSRegsFile\")\r\n#else\r\n#pragma DATA_SECTION(ECanaMOTSRegs,\"ECanaMOTSRegsFile\");\r\n#endif\r\nvolatile struct MOTS_REGS ECanaMOTSRegs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"ECanaMOTORegsFile\")\r\n#else\r\n#pragma DATA_SECTION(ECanaMOTORegs,\"ECanaMOTORegsFile\");\r\n#endif\r\nvolatile struct MOTO_REGS ECanaMOTORegs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"EPwm1RegsFile\")\r\n#else\r\n#pragma DATA_SECTION(EPwm1Regs,\"EPwm1RegsFile\");\r\n#endif\r\nvolatile struct EPWM_REGS EPwm1Regs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"EPwm2RegsFile\")\r\n#else\r\n#pragma DATA_SECTION(EPwm2Regs,\"EPwm2RegsFile\");\r\n#endif\r\nvolatile struct EPWM_REGS EPwm2Regs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"EPwm3RegsFile\")\r\n#else\r\n#pragma DATA_SECTION(EPwm3Regs,\"EPwm3RegsFile\");\r\n#endif\r\nvolatile struct EPWM_REGS EPwm3Regs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"EPwm4RegsFile\")\r\n#else\r\n#pragma DATA_SECTION(EPwm4Regs,\"EPwm4RegsFile\");\r\n#endif\r\nvolatile struct EPWM_REGS EPwm4Regs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"EPwm5RegsFile\")\r\n#else\r\n#pragma DATA_SECTION(EPwm5Regs,\"EPwm5RegsFile\");\r\n#endif\r\nvolatile struct EPWM_REGS EPwm5Regs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"EPwm6RegsFile\")\r\n#else\r\n#pragma DATA_SECTION(EPwm6Regs,\"EPwm6RegsFile\");\r\n#endif\r\nvolatile struct EPWM_REGS EPwm6Regs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"EPwm7RegsFile\")\r\n#else\r\n#pragma DATA_SECTION(EPwm7Regs,\"EPwm7RegsFile\");\r\n#endif\r\nvolatile struct EPWM_REGS EPwm7Regs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"EPwm8RegsFile\")\r\n#else\r\n#pragma DATA_SECTION(EPwm8Regs,\"EPwm8RegsFile\");\r\n#endif\r\nvolatile struct EPWM_REGS EPwm8Regs;\r\n\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"ECap1RegsFile\")\r\n#else\r\n#pragma DATA_SECTION(ECap1Regs,\"ECap1RegsFile\");\r\n#endif\r\nvolatile struct ECAP_REGS ECap1Regs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"ECap2RegsFile\")\r\n#else\r\n#pragma DATA_SECTION(ECap2Regs,\"ECap2RegsFile\");\r\n#endif\r\nvolatile struct ECAP_REGS ECap2Regs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"ECap3RegsFile\")\r\n#else\r\n#pragma DATA_SECTION(ECap3Regs,\"ECap3RegsFile\");\r\n#endif\r\nvolatile struct ECAP_REGS ECap3Regs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"EQep1RegsFile\")\r\n#else\r\n#pragma DATA_SECTION(EQep1Regs,\"EQep1RegsFile\");\r\n#endif\r\nvolatile struct EQEP_REGS EQep1Regs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"EQep2RegsFile\")\r\n#else\r\n#pragma DATA_SECTION(EQep2Regs,\"EQep2RegsFile\");\r\n#endif\r\nvolatile struct EQEP_REGS EQep2Regs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"FlashRegsFile\")\r\n#else\r\n#pragma DATA_SECTION(FlashRegs,\"FlashRegsFile\");\r\n#endif\r\nvolatile struct FLASH_REGS FlashRegs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"GpioCtrlRegsFile\")\r\n#else\r\n#pragma DATA_SECTION(GpioCtrlRegs,\"GpioCtrlRegsFile\");\r\n#endif\r\nvolatile struct GPIO_CTRL_REGS GpioCtrlRegs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"GpioDataRegsFile\")\r\n#else\r\n#pragma DATA_SECTION(GpioDataRegs,\"GpioDataRegsFile\");\r\n#endif\r\nvolatile struct GPIO_DATA_REGS GpioDataRegs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"GpioIntRegsFile\")\r\n#else\r\n#pragma DATA_SECTION(GpioIntRegs,\"GpioIntRegsFile\");\r\n#endif\r\nvolatile struct GPIO_INT_REGS GpioIntRegs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"HRCap1RegsFile\")\r\n#else\r\n#pragma DATA_SECTION(HRCap1Regs,\"HRCap1RegsFile\");\r\n#endif\r\nvolatile struct HRCAP_REGS HRCap1Regs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"HRCap2RegsFile\")\r\n#else\r\n#pragma DATA_SECTION(HRCap2Regs,\"HRCap2RegsFile\");\r\n#endif\r\nvolatile struct HRCAP_REGS HRCap2Regs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"HRCap3RegsFile\")\r\n#else\r\n#pragma DATA_SECTION(HRCap3Regs,\"HRCap3RegsFile\");\r\n#endif\r\nvolatile struct HRCAP_REGS HRCap3Regs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"HRCap4RegsFile\")\r\n#else\r\n#pragma DATA_SECTION(HRCap4Regs,\"HRCap4RegsFile\");\r\n#endif\r\nvolatile struct HRCAP_REGS HRCap4Regs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"I2caRegsFile\")\r\n#else\r\n#pragma DATA_SECTION(I2caRegs,\"I2caRegsFile\");\r\n#endif\r\nvolatile struct I2C_REGS I2caRegs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"McbspaRegsFile\")\r\n#else\r\n#pragma DATA_SECTION(McbspaRegs,\"McbspaRegsFile\");\r\n#endif\r\nvolatile struct McBSP_REGS McbspaRegs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"NmiIntruptRegsFile\")\r\n#else\r\n#pragma DATA_SECTION(NmiIntruptRegs,\"NmiIntruptRegsFile\");\r\n#endif\r\nvolatile struct NMIINTRUPT_REGS NmiIntruptRegs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"PartIdRegsFile\")\r\n#else\r\n#pragma DATA_SECTION(PartIdRegs,\"PartIdRegsFile\");\r\n#endif\r\nvolatile struct PARTID_REGS PartIdRegs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"PieCtrlRegsFile\")\r\n#else\r\n#pragma DATA_SECTION(PieCtrlRegs,\"PieCtrlRegsFile\");\r\n#endif\r\nvolatile struct PIE_CTRL_REGS PieCtrlRegs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"PieVectTableFile\")\r\n#else\r\n#pragma DATA_SECTION(PieVectTable,\"PieVectTableFile\");\r\n#endif\r\nvolatile struct PIE_VECT_TABLE PieVectTable;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"SciaRegsFile\")\r\n#else\r\n#pragma DATA_SECTION(SciaRegs,\"SciaRegsFile\");\r\n#endif\r\nvolatile struct SCI_REGS SciaRegs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"ScibRegsFile\")\r\n#else\r\n#pragma DATA_SECTION(ScibRegs,\"ScibRegsFile\");\r\n#endif\r\nvolatile struct SCI_REGS ScibRegs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"SpiaRegsFile\")\r\n#else\r\n#pragma DATA_SECTION(SpiaRegs,\"SpiaRegsFile\");\r\n#endif\r\nvolatile struct SPI_REGS SpiaRegs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"SpibRegsFile\")\r\n#else\r\n#pragma DATA_SECTION(SpibRegs,\"SpibRegsFile\");\r\n#endif\r\nvolatile struct SPI_REGS SpibRegs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"SysCtrlRegsFile\")\r\n#else\r\n#pragma DATA_SECTION(SysCtrlRegs,\"SysCtrlRegsFile\");\r\n#endif\r\nvolatile struct SYS_CTRL_REGS SysCtrlRegs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"SysPwrCtrlRegsFile\")\r\n#else\r\n#pragma DATA_SECTION(SysPwrCtrlRegs,\"SysPwrCtrlRegsFile\");\r\n#endif\r\nvolatile struct SYS_PWR_CTRL_REGS SysPwrCtrlRegs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"Usb0RegsFile\")\r\n#else\r\n#pragma DATA_SECTION(Usb0Regs,\"Usb0RegsFile\");\r\n#endif\r\nvolatile struct USB_REGS Usb0Regs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"XIntruptRegsFile\")\r\n#else\r\n#pragma DATA_SECTION(XIntruptRegs,\"XIntruptRegsFile\");\r\n#endif\r\nvolatile struct XINTRUPT_REGS XIntruptRegs;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"EmuKeyVar\");\r\n#else\r\n#pragma DATA_SECTION(EmuKey,\"EmuKeyVar\");\r\n#endif\r\nUint16 EmuKey;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"EmuBModeVar\");\r\n#else\r\n#pragma DATA_SECTION(EmuBMode,\"EmuBModeVar\");\r\n#endif\r\nUint16 EmuBMode;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"FlashScalingVar\");\r\n#else\r\n#pragma DATA_SECTION(Flash_CPUScaleFactor, \"FlashScalingVar\");\r\n#endif\r\nUint32 Flash_CPUScaleFactor;\r\n\r\n//----------------------------------------\r\n#ifdef __cplusplus\r\n#pragma DATA_SECTION(\"FlashCallbackVar\");\r\n#else\r\n#pragma DATA_SECTION(Flash_CallbackPtr, \"FlashCallbackVar\");\r\n#endif\r\nvoid (*Flash_CallbackPtr) (void);\r\n\r\n\r\n//===========================================================================\r\n// End of file.\r\n//===========================================================================\r\n\r\n"},{"name":"F2806x_HRCap.c","type":"source","group":"legacy","path":"C:\\Users\\rodri\\git\\bruno\\mbd-elevator\\matlab\\controller_base_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ti\\controlSUITE\\device_support\\f2806x\\v151\\F2806x_common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\r\n//\r\n// FILE:   F2806x_HRCap.c\r\n//\r\n// TITLE:  F2806x HRCap Initialization & Support Functions.\r\n//\r\n//###########################################################################\r\n// $TI Release: F2806x C/C++ Header Files and Peripheral Examples V151 $\r\n// $Release Date: February  2, 2016 $\r\n// $Copyright: Copyright (C) 2011-2016 Texas Instruments Incorporated -\n//             http://www.ti.com/ ALL RIGHTS RESERVED $\n//###########################################################################\r\n\r\n#include \"F2806x_Device.h\"     // F2806x Headerfile Include File\r\n#include \"F2806x_Examples.h\"   // F2806x Examples Include File\r\n\r\n//---------------------------------------------------------------------------\r\n// InitEPwm:\r\n//---------------------------------------------------------------------------\r\n// This function initializes the HRCap(s) to a known state.\r\n//\r\nvoid InitHRCap(void)\r\n{\r\n   // Initialize HRCap1/2/3/4\r\n\r\n   //tbd...\r\n\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n// Example: InitHRCapGpio:\r\n//---------------------------------------------------------------------------\r\n// This function initializes GPIO pins to function as EPwm pins\r\n//\r\n// Each GPIO pin can be configured as a GPIO pin or up to 3 different\r\n// peripheral functional pins. By default all pins come up as GPIO\r\n// inputs after reset.\r\n//\r\n\r\nvoid InitHRCapGpio(void)\r\n{\r\n   #if DSP28_HRCAP1\r\n   \t   InitHRCap1Gpio();\r\n   #endif // endif DSP28_HRCAP1\r\n   #if DSP28_HRCAP2\r\n       InitHRCap2Gpio();\r\n   #endif // endif DSP28_HRCAP2\r\n   #if DSP28_HRCAP3\r\n       InitHRCap3Gpio();\r\n   #endif // endif DSP28_HRCAP3\r\n   #if DSP28_HRCAP4\r\n       InitHRCap4Gpio();\r\n   #endif // endif DSP28_HRCAP4\r\n}\r\n\r\n#if DSP28_HRCAP1\r\nvoid InitHRCap1Gpio(void)\r\n{\r\n   EALLOW;\r\n\r\n/* Enable internal pull-up for the selected pins */\r\n// Pull-ups can be enabled or disabled by the user.\r\n// This will enable the pullups for the specified pins.\r\n// Comment out other unwanted lines.\r\n\r\n   GpioCtrlRegs.GPBPUD.bit.GPIO54 = 0;\t\t// Enable pull-up on GPIO54 (HRCAP1)\r\n\r\n// Inputs are synchronized to SYSCLKOUT by default.\r\n// Comment out other unwanted lines.\r\n\r\n   GpioCtrlRegs.GPBQSEL2.bit.GPIO54 = 3;\t\t// Asynch to SYSCLKOUT GPIO54 (HRCAP1)\r\n\r\n/* Configure HRCAP-1 pins using GPIO regs*/\r\n// This specifies which of the possible GPIO pins will be HRCAP1 functional pins.\r\n// Comment out other unwanted lines.\r\n\r\n   GpioCtrlRegs.GPBMUX2.bit.GPIO54 = 3;\t\t// Configure GPIO54 as HRCAP1\r\n\r\n   EDIS;\r\n}\r\n#endif // endif DSP28_HRCAP1\r\n\r\n#if DSP28_HRCAP2\r\nvoid InitHRCap2Gpio(void)\r\n{\r\n   EALLOW;\r\n\r\n/* Enable internal pull-up for the selected pins */\r\n// Pull-ups can be enabled or disabled by the user.\r\n// This will enable the pullups for the specified pins.\r\n// Comment out other unwanted lines.\r\n\r\n   GpioCtrlRegs.GPAPUD.bit.GPIO27 = 0;\t\t// Enable pull-up on GPIO27 (HRCAP2)\r\n// GpioCtrlRegs.GPBPUD.bit.GPIO55 = 0;\t\t// Enable pull-up on GPIO55 (HRCAP2)\r\n\r\n// Inputs are synchronized to SYSCLKOUT by default.\r\n// Comment out other unwanted lines.\r\n\r\n   GpioCtrlRegs.GPAQSEL2.bit.GPIO27 = 3;\t\t// Asynch to SYSCLKOUT GPIO27 (HRCAP2)\r\n// GpioCtrlRegs.GPBQSEL2.bit.GPIO55 = 3;\t\t// Asynch to SYSCLKOUT GPIO55 (HRCAP2)\r\n\r\n/* Configure HRCAP-2 pins using GPIO regs*/\r\n// This specifies which of the possible GPIO pins will be HRCAP2 functional pins.\r\n// Comment out other unwanted lines.\r\n\r\n   GpioCtrlRegs.GPAMUX2.bit.GPIO27 = 1;\t\t// Configure GPIO27 as HRCAP2\r\n// GpioCtrlRegs.GPBMUX2.bit.GPIO55 = 3;\t\t// Configure GPIO55 as HRCAP2\r\n\r\n   EDIS;\r\n}\r\n#endif // endif DSP28_HRCAP2\r\n\r\n#if DSP28_HRCAP3\r\nvoid InitHRCap3Gpio(void)\r\n{\r\n   EALLOW;\r\n\r\n/* Enable internal pull-up for the selected pins */\r\n// Pull-ups can be enabled or disabled by the user.\r\n// This will enable the pullups for the specified pins.\r\n// Comment out other unwanted lines.\r\n\r\n   GpioCtrlRegs.GPBPUD.bit.GPIO56 = 0;\t\t// Enable pull-up on GPIO56 (HRCAP3)\r\n\r\n// Inputs are synchronized to SYSCLKOUT by default.\r\n// Comment out other unwanted lines.\r\n\r\n   GpioCtrlRegs.GPBQSEL2.bit.GPIO56 = 3;\t\t// Asynch to SYSCLKOUT GPIO56 (HRCAP3)\r\n\r\n/* Configure HRCAP-3 pins using GPIO regs*/\r\n// This specifies which of the possible GPIO pins will be HRCAP3 functional pins.\r\n// Comment out other unwanted lines.\r\n\r\n   GpioCtrlRegs.GPBMUX2.bit.GPIO56 = 3;\t\t// Configure GPIO56 as HRCAP3\r\n\r\n   EDIS;\r\n}\r\n#endif // endif DSP28_HRCAP3\r\n\r\n#if DSP28_HRCAP4\r\nvoid InitHRCap4Gpio(void)\r\n{\r\n   EALLOW;\r\n\r\n/* Enable internal pull-up for the selected pins */\r\n// Pull-ups can be enabled or disabled by the user.\r\n// This will enable the pullups for the specified pins.\r\n// Comment out other unwanted lines.\r\n\r\n   GpioCtrlRegs.GPBPUD.bit.GPIO57 = 0;\t\t// Enable pull-up on GPIO57 (HRCAP4)\r\n\r\n// Inputs are synchronized to SYSCLKOUT by default.\r\n// Comment out other unwanted lines.\r\n\r\n   GpioCtrlRegs.GPBQSEL2.bit.GPIO57 = 3;\t\t// Asynch to SYSCLKOUT GPIO57 (HRCAP4)\r\n\r\n/* Configure HRCAP-4 pins using GPIO regs*/\r\n// This specifies which of the possible GPIO pins will be HRCAP4 functional pins.\r\n// Comment out other unwanted lines.\r\n\r\n   GpioCtrlRegs.GPBMUX2.bit.GPIO57 = 3;\t\t// Configure GPIO57 as HRCAP4\r\n\r\n   EDIS;\r\n}\r\n#endif // endif DSP28_HRCAP4\r\n\r\n//===========================================================================\r\n// End of file.\r\n//===========================================================================\r\n"},{"name":"F2806x_PieCtrl.c","type":"source","group":"legacy","path":"C:\\Users\\rodri\\git\\bruno\\mbd-elevator\\matlab\\controller_base_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ti\\controlSUITE\\device_support\\f2806x\\v151\\F2806x_common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\r\n//\r\n// FILE:\tF2806x_PieCtrl.c\r\n//\r\n// TITLE:\tF2806x Device PIE Control Register Initialization Functions.\r\n//\r\n//###########################################################################\r\n// $TI Release: F2806x C/C++ Header Files and Peripheral Examples V151 $\r\n// $Release Date: February  2, 2016 $\r\n// $Copyright: Copyright (C) 2011-2016 Texas Instruments Incorporated -\n//             http://www.ti.com/ ALL RIGHTS RESERVED $\n//###########################################################################\r\n\r\n#include \"F2806x_Device.h\"     // F2806x Headerfile Include File\r\n#include \"F2806x_Examples.h\"   // F2806x Examples Include File\r\n\r\n//---------------------------------------------------------------------------\r\n// InitPieCtrl:\r\n//---------------------------------------------------------------------------\r\n// This function initializes the PIE control registers to a known state.\r\n//\r\nvoid InitPieCtrl(void)\r\n{\r\n    // Disable Interrupts at the CPU level:\r\n    DINT;\r\n\r\n    // Disable the PIE\r\n    PieCtrlRegs.PIECTRL.bit.ENPIE = 0;\r\n\r\n\t// Clear all PIEIER registers:\r\n\tPieCtrlRegs.PIEIER1.all = 0;\r\n\tPieCtrlRegs.PIEIER2.all = 0;\r\n\tPieCtrlRegs.PIEIER3.all = 0;\r\n\tPieCtrlRegs.PIEIER4.all = 0;\r\n\tPieCtrlRegs.PIEIER5.all = 0;\r\n\tPieCtrlRegs.PIEIER6.all = 0;\r\n\tPieCtrlRegs.PIEIER7.all = 0;\r\n\tPieCtrlRegs.PIEIER8.all = 0;\r\n\tPieCtrlRegs.PIEIER9.all = 0;\r\n\tPieCtrlRegs.PIEIER10.all = 0;\r\n\tPieCtrlRegs.PIEIER11.all = 0;\r\n\tPieCtrlRegs.PIEIER12.all = 0;\r\n\r\n\t// Clear all PIEIFR registers:\r\n\tPieCtrlRegs.PIEIFR1.all = 0;\r\n\tPieCtrlRegs.PIEIFR2.all = 0;\r\n\tPieCtrlRegs.PIEIFR3.all = 0;\r\n\tPieCtrlRegs.PIEIFR4.all = 0;\r\n\tPieCtrlRegs.PIEIFR5.all = 0;\r\n\tPieCtrlRegs.PIEIFR6.all = 0;\r\n\tPieCtrlRegs.PIEIFR7.all = 0;\r\n\tPieCtrlRegs.PIEIFR8.all = 0;\r\n\tPieCtrlRegs.PIEIFR9.all = 0;\r\n\tPieCtrlRegs.PIEIFR10.all = 0;\r\n\tPieCtrlRegs.PIEIFR11.all = 0;\r\n\tPieCtrlRegs.PIEIFR12.all = 0;\r\n\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n// EnableInterrupts:\r\n//---------------------------------------------------------------------------\r\n// This function enables the PIE module and CPU interrupts\r\n//\r\nvoid EnableInterrupts()\r\n{\r\n\r\n    // Enable the PIE\r\n    PieCtrlRegs.PIECTRL.bit.ENPIE = 1;\r\n\r\n\t// Enables PIE to drive a pulse into the CPU\r\n\tPieCtrlRegs.PIEACK.all = 0xFFFF;\r\n\r\n\t// Enable Interrupts at the CPU level\r\n    EINT;\r\n\r\n}\r\n\r\n//===========================================================================\r\n// End of file.\r\n//===========================================================================\r\n"},{"name":"F2806x_PieVect.c","type":"source","group":"legacy","path":"C:\\Users\\rodri\\git\\bruno\\mbd-elevator\\matlab\\controller_base_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ti\\controlSUITE\\device_support\\f2806x\\v151\\F2806x_common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\r\n//\r\n// FILE:\tF2806x_PieVect.c\r\n//\r\n// TITLE:\tF2806x Devices PIE Vector Table Initialization Functions.\r\n//\r\n//###########################################################################\r\n// $TI Release: F2806x C/C++ Header Files and Peripheral Examples V151 $\r\n// $Release Date: February  2, 2016 $\r\n// $Copyright: Copyright (C) 2011-2016 Texas Instruments Incorporated -\n//             http://www.ti.com/ ALL RIGHTS RESERVED $\n//###########################################################################\r\n\r\n#include \"F2806x_Device.h\"     // F2806x Headerfile Include File\r\n#include \"F2806x_Examples.h\"   // F2806x Examples Include File\r\n\r\nconst struct PIE_VECT_TABLE PieVectTableInit = {\r\n\r\n      PIE_RESERVED,  // 1  Reserved space\r\n      PIE_RESERVED,  // 2  Reserved space\r\n      PIE_RESERVED,  // 3  Reserved space\r\n      PIE_RESERVED,  // 4  Reserved space\r\n      PIE_RESERVED,  // 5  Reserved space\r\n      PIE_RESERVED,  // 6  Reserved space\r\n      PIE_RESERVED,  // 7  Reserved space\r\n      PIE_RESERVED,  // 8  Reserved space\r\n      PIE_RESERVED,  // 9  Reserved space\r\n      PIE_RESERVED,  // 10 Reserved space\r\n      PIE_RESERVED,  // 11 Reserved space\r\n      PIE_RESERVED,  // 12 Reserved space\r\n      PIE_RESERVED,  // 13 Reserved space\r\n\r\n// Non-Peripheral Interrupts\r\n      INT13_ISR,     // CPU-Timer 1\r\n      INT14_ISR,     // CPU-Timer 2\r\n      DATALOG_ISR,   // Datalogging interrupt\r\n      RTOSINT_ISR,   // RTOS interrupt\r\n      EMUINT_ISR,    // Emulation interrupt\r\n      NMI_ISR,       // Non-maskable interrupt\r\n      ILLEGAL_ISR,   // Illegal operation TRAP\r\n      USER1_ISR,     // User Defined trap 1\r\n      USER2_ISR,     // User Defined trap 2\r\n      USER3_ISR,     // User Defined trap 3\r\n      USER4_ISR,     // User Defined trap 4\r\n      USER5_ISR,     // User Defined trap 5\r\n      USER6_ISR,     // User Defined trap 6\r\n      USER7_ISR,     // User Defined trap 7\r\n      USER8_ISR,     // User Defined trap 8\r\n      USER9_ISR,     // User Defined trap 9\r\n      USER10_ISR,    // User Defined trap 10\r\n      USER11_ISR,    // User Defined trap 11\r\n      USER12_ISR,    // User Defined trap 12\r\n\r\n// Group 1 PIE Vectors\r\n      ADCINT1_ISR,     // 1.1 ADC  ADC - make rsvd1_1 if ADCINT1 is wanted in Group 10 instead.\r\n      ADCINT2_ISR,     // 1.2 ADC  ADC - make rsvd1_2 if ADCINT2 is wanted in Group 10 instead.\r\n      rsvd_ISR,        // 1.3\r\n      XINT1_ISR,       // 1.4 External Interrupt\r\n      XINT2_ISR,       // 1.5 External Interrupt\r\n      ADCINT9_ISR,     // 1.6 ADC Interrupt 9\r\n      TINT0_ISR,       // 1.7 Timer 0\r\n      WAKEINT_ISR,     // 1.8 WD, Low Power\r\n\r\n// Group 2 PIE Vectors\r\n      EPWM1_TZINT_ISR, // 2.1 EPWM-1 Trip Zone\r\n      EPWM2_TZINT_ISR, // 2.2 EPWM-2 Trip Zone\r\n      EPWM3_TZINT_ISR, // 2.3 EPWM-3 Trip Zone\r\n      EPWM4_TZINT_ISR, // 2.4 EPWM-4 Trip Zone\r\n      EPWM5_TZINT_ISR, // 2.5 EPWM-5 Trip Zone\r\n      EPWM6_TZINT_ISR, // 2.6 EPWM-6 Trip Zone\r\n      EPWM7_TZINT_ISR, // 2.7 EPWM-7 Trip Zone\r\n      EPWM8_TZINT_ISR, // 2.8 EPWM-8 Trip Zone\r\n\r\n// Group 3 PIE Vectors\r\n      EPWM1_INT_ISR,   // 3.1 EPWM-1 Interrupt\r\n      EPWM2_INT_ISR,   // 3.2 EPWM-2 Interrupt\r\n      EPWM3_INT_ISR,   // 3.3 EPWM-3 Interrupt\r\n      EPWM4_INT_ISR,   // 3.4 EPWM-4 Interrupt\r\n      EPWM5_INT_ISR,   // 3.5 EPWM-5 Interrupt\r\n      EPWM6_INT_ISR,   // 3.6 EPWM-6 Interrupt\r\n      EPWM7_INT_ISR,   // 3.7 EPWM-7 Interrupt\r\n      EPWM8_INT_ISR,   // 3.8 EPWM-8 Interrupt\r\n\r\n// Group 4 PIE Vectors\r\n      ECAP1_INT_ISR,   // 4.1 ECAP-1\r\n      ECAP2_INT_ISR,   // 4.2 ECAP-2\r\n      ECAP3_INT_ISR,   // 4.3 ECAP-3\r\n      rsvd_ISR,   \t   // 4.4\r\n      rsvd_ISR,        // 4.5\r\n      rsvd_ISR,        // 4.6\r\n      HRCAP1_INT_ISR,  // 4.7 HRCAP-1\r\n      HRCAP2_INT_ISR,  // 4.8 HRCAP-2\r\n\r\n// Group 5 PIE Vectors\r\n\r\n      EQEP1_INT_ISR,   // 5.1 EQEP-1\r\n      EQEP2_INT_ISR,   // 5.2 EQEP-2\r\n      rsvd_ISR,   \t   // 5.3\r\n      HRCAP3_INT_ISR,  // 5.4 HRCAP-3\r\n      HRCAP4_INT_ISR,  // 5.5 HRCAP-4\r\n      rsvd_ISR,        // 5.6\r\n      rsvd_ISR,        // 5.7\r\n      USB0_INT_ISR,    // 5.8 USB-0\r\n\r\n// Group 6 PIE Vectors\r\n      SPIRXINTA_ISR,   // 6.1 SPI-A\r\n      SPITXINTA_ISR,   // 6.2 SPI-A\r\n      SPIRXINTB_ISR,   // 6.3 SPI-B\r\n      SPITXINTA_ISR,   // 6.4 SPI-B\r\n      MRINTA_ISR,      // 6.5 McBSP-A\r\n      MXINTA_ISR,      // 6.6 McBSP-A\r\n      rsvd_ISR,        // 6.7\r\n      rsvd_ISR,        // 6.8\r\n\r\n// Group 7 PIE Vectors\r\n      DINTCH1_ISR,     // 7.1 DMA Channel 1\r\n      DINTCH2_ISR,     // 7.2 DMA Channel 2\r\n      DINTCH3_ISR,     // 7.3 DMA Channel 3\r\n      DINTCH4_ISR,     // 7.4 DMA Channel 4\r\n      DINTCH5_ISR,     // 7.5 DMA Channel 5\r\n      DINTCH6_ISR,     // 7.6 DMA Channel 6\r\n      rsvd_ISR,        // 7.7\r\n      rsvd_ISR,        // 7.8\r\n\r\n// Group 8 PIE Vectors\r\n      I2CINT1A_ISR,    // 8.1 I2C-A\r\n      I2CINT2A_ISR,    // 8.2 I2C-A\r\n      rsvd_ISR,        // 8.3\r\n      rsvd_ISR,        // 8.4\r\n      rsvd_ISR,        // 8.5\r\n      rsvd_ISR,        // 8.6\r\n      rsvd_ISR,        // 8.7\r\n      rsvd_ISR,        // 8.8\r\n\r\n// Group 9 PIE Vectors\r\n      SCIRXINTA_ISR,   // 9.1 SCI-A\r\n      SCITXINTA_ISR,   // 9.2 SCI-A\r\n      SCIRXINTB_ISR,   // 9.3 SCI-B\r\n      SCITXINTB_ISR,   // 9.4 SCI-B\r\n      ECAN0INTA_ISR,   // 9.5 ECAN-A\r\n      ECAN1INTA_ISR,   // 9.6 ECAN-A\r\n      rsvd_ISR,        // 9.7\r\n      rsvd_ISR,        // 9.8\r\n\r\n// Group 10 PIE Vectors\r\n      rsvd_ISR,        // 10.1 Can be ADCINT1, but must make ADCINT1 in Group 1 space \"reserved\".\r\n      rsvd_ISR,        // 10.2 Can be ADCINT2, but must make ADCINT2 in Group 1 space \"reserved\".\r\n      ADCINT3_ISR,     // 10.3 ADC\r\n      ADCINT4_ISR,     // 10.4 ADC\r\n      ADCINT5_ISR,     // 10.5 ADC\r\n      ADCINT6_ISR,     // 10.6 ADC\r\n      ADCINT7_ISR,     // 10.7 ADC\r\n      ADCINT8_ISR,     // 10.8 ADC\r\n\r\n// Group 11 PIE Vectors\r\n      CLA1_INT1_ISR,   // 11.1 CLA1\r\n\t  CLA1_INT2_ISR,   // 11.2 CLA1\r\n\t  CLA1_INT3_ISR,   // 11.3 CLA1\r\n\t  CLA1_INT4_ISR,   // 11.4 CLA1\r\n\t  CLA1_INT5_ISR,   // 11.5 CLA1\r\n\t  CLA1_INT6_ISR,   // 11.6 CLA1\r\n\t  CLA1_INT7_ISR,   // 11.7 CLA1\r\n      CLA1_INT8_ISR,   // 11.8 CLA1\r\n\r\n// Group 12 PIE Vectors\r\n      XINT3_ISR,       // 12.1 External Interrupt\r\n      rsvd_ISR,        // 12.2\r\n      rsvd_ISR,        // 12.3\r\n      rsvd_ISR,        // 12.4\r\n      rsvd_ISR,        // 12.5\r\n      rsvd_ISR,        // 12.6\r\n      LVF_ISR,         // 12.7 Latched Overflow\r\n      LUF_ISR          // 12.8 Latched Underflow\r\n};\r\n\r\n//---------------------------------------------------------------------------\r\n// InitPieVectTable:\r\n//---------------------------------------------------------------------------\r\n// This function initializes the PIE vector table to a known state.\r\n// This function must be executed after boot time.\r\n//\r\n\r\nvoid InitPieVectTable(void)\r\n{\r\n\tint16\ti;\r\n\tUint32 *Source = (void *) &PieVectTableInit;\r\n\tUint32 *Dest = (void *) &PieVectTable;\r\n\r\n\t// Do not write over first 3 32-bit locations (these locations are\r\n\t// initialized by Boot ROM with boot variables)\r\n\r\n\tSource = Source + 3;\r\n\tDest = Dest + 3;\r\n\r\n\tEALLOW;\r\n\tfor(i=0; i < 125; i++)\r\n\t\t*Dest++ = *Source++;\r\n\tEDIS;\r\n\r\n\t// Enable the PIE Vector Table\r\n\tPieCtrlRegs.PIECTRL.bit.ENPIE = 1;\r\n\r\n}\r\n\r\n//===========================================================================\r\n// End of file.\r\n//===========================================================================\r\n"},{"name":"F2806x_SysCtrl.c","type":"source","group":"legacy","path":"C:\\Users\\rodri\\git\\bruno\\mbd-elevator\\matlab\\controller_base_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ti\\controlSUITE\\device_support\\f2806x\\v151\\F2806x_common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\r\n//\r\n// FILE:   F2806x_SysCtrl.c\r\n//\r\n// TITLE:  F2806x Device System Control Initialization & Support Functions.\r\n//\r\n// DESCRIPTION:\r\n//\r\n//         Example initialization of system resources.\r\n//\r\n//###########################################################################\r\n// $TI Release: F2806x C/C++ Header Files and Peripheral Examples V151 $\r\n// $Release Date: February  2, 2016 $\r\n// $Copyright: Copyright (C) 2011-2016 Texas Instruments Incorporated -\n//             http://www.ti.com/ ALL RIGHTS RESERVED $\n//###########################################################################\r\n\r\n#include \"F2806x_Device.h\"     // Headerfile Include File\r\n#include \"F2806x_Examples.h\"   // Examples Include File\r\n\r\n// Functions that will be run from RAM need to be assigned to\r\n// a different section.  This section will then be mapped to a load and\r\n// run address using the linker cmd file.\r\n//\r\n//  *IMPORTANT*\r\n//  IF RUNNING FROM FLASH, PLEASE COPY OVER THE SECTION \"ramfuncs\"  FROM FLASH\r\n//  TO RAM PRIOR TO CALLING InitSysCtrl(). THIS PREVENTS THE MCU FROM THROWING \r\n//  AN EXCEPTION WHEN A CALL TO DELAY_US() IS MADE. \r\n//\r\n#pragma CODE_SECTION(InitFlash, \"ramfuncs\");\r\n\r\n//---------------------------------------------------------------------------\r\n// InitSysCtrl:\r\n//---------------------------------------------------------------------------\r\n// This function initializes the System Control registers to a known state.\r\n// - Disables the watchdog\r\n// - Set the PLLCR for proper SYSCLKOUT frequency\r\n// - Set the pre-scaler for the high and low frequency peripheral clocks\r\n// - Enable the clocks to the peripherals\r\n\r\nvoid InitSysCtrl(void)\r\n{\r\n\r\n   // Disable the watchdog\r\n   DisableDog();\r\n\r\n   // *IMPORTANT*\r\n   // The Device_cal function, which copies the ADC & oscillator calibration values\r\n   // from TI reserved OTP into the appropriate trim registers, occurs automatically\r\n   // in the Boot ROM. If the boot ROM code is bypassed during the debug process, the\r\n   // following function MUST be called for the ADC and oscillators to function according\r\n   // to specification. The clocks to the ADC MUST be enabled before calling this\r\n   // function.\r\n   // See the device data manual and/or the ADC Reference\r\n   // Manual for more information.\r\n\r\n   EALLOW;\r\n   SysCtrlRegs.PCLKCR0.bit.ADCENCLK = 1; // Enable ADC peripheral clock\r\n   (*Device_cal)();\r\n   SysCtrlRegs.PCLKCR0.bit.ADCENCLK = 0; // Return ADC clock to original state\r\n   EDIS;\r\n\r\n   // Select Internal Oscillator 1 as Clock Source (default), and turn off all unused clocks to\r\n   // conserve power.\r\n   IntOsc1Sel();\r\n\r\n   // Initialize the PLL control: PLLCR and CLKINDIV\r\n   // DSP28_PLLCR and DSP28_CLKINDIV are defined in F2806x_Examples.h\r\n   InitPll(DSP28_PLLCR,DSP28_DIVSEL);\r\n   \r\n   // Initialize the peripheral clocks\r\n   InitPeripheralClocks();\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n// Example: InitFlash:\r\n//---------------------------------------------------------------------------\r\n// This function initializes the Flash Control registers for operation at\r\n// 90MHz.  If you are running slower flash wait states can be lessened.\r\n// Refer to the datasheet for propper flash wait state values.\r\n\r\n//                   CAUTION\r\n// This function MUST be executed out of RAM. Executing it\r\n// out of OTP/Flash will yield unpredictable results\r\n\r\nvoid InitFlash(void)\r\n{\r\n   EALLOW;\r\n   //Enable Flash Pipeline mode to improve performance\r\n   //of code executed from Flash.\r\n   FlashRegs.FOPT.bit.ENPIPE = 1;\r\n\r\n   //                CAUTION\r\n   //Minimum waitstates required for the flash operating\r\n   //at a given CPU rate must be characterized by TI.\r\n   //Refer to the datasheet for the latest information.\r\n\r\n   //Set the Paged Waitstate for the Flash\r\n   FlashRegs.FBANKWAIT.bit.PAGEWAIT = 3;\r\n\r\n   //Set the Random Waitstate for the Flash\r\n   FlashRegs.FBANKWAIT.bit.RANDWAIT = 3;\r\n\r\n   //Set the Waitstate for the OTP\r\n   FlashRegs.FOTPWAIT.bit.OTPWAIT = 5;\r\n\r\n   //                CAUTION\r\n   //ONLY THE DEFAULT VALUE FOR THESE 2 REGISTERS SHOULD BE USED\r\n   FlashRegs.FSTDBYWAIT.bit.STDBYWAIT = 0x01FF;\r\n   FlashRegs.FACTIVEWAIT.bit.ACTIVEWAIT = 0x01FF;\r\n   EDIS;\r\n\r\n   //Force a pipeline flush to ensure that the write to\r\n   //the last register configured occurs before returning.\r\n\r\n  __asm(\" RPT #7 || NOP\");\n}\r\n\r\n//---------------------------------------------------------------------------\r\n// Example: ServiceDog:\r\n//---------------------------------------------------------------------------\r\n// This function resets the watchdog timer.\r\n// Enable this function for using ServiceDog in the application\r\n\r\nvoid ServiceDog(void)\r\n{\r\n    EALLOW;\r\n    SysCtrlRegs.WDKEY = 0x0055;\r\n    SysCtrlRegs.WDKEY = 0x00AA;\r\n    EDIS;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n// Example: DisableDog:\r\n//---------------------------------------------------------------------------\r\n// This function disables the watchdog timer.\r\n\r\nvoid DisableDog(void)\r\n{\r\n    EALLOW;\r\n    SysCtrlRegs.WDCR= 0x0068;\r\n    EDIS;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n// Example: InitPll:\r\n//---------------------------------------------------------------------------\r\n// This function initializes the PLLCR register.\r\n\r\nvoid InitPll(Uint16 val, Uint16 divsel)\r\n{\r\n   volatile Uint16 iVol;\r\n\r\n   // Make sure the PLL is not running in limp mode\r\n   if (SysCtrlRegs.PLLSTS.bit.MCLKSTS != 0)\r\n   {\r\n      EALLOW;\r\n      // OSCCLKSRC1 failure detected. PLL running in limp mode.\r\n      // Re-enable missing clock logic.\r\n      SysCtrlRegs.PLLSTS.bit.MCLKCLR = 1;\r\n      EDIS;\r\n      // Replace this line with a call to an appropriate\r\n      // SystemShutdown(); function.\r\n     __asm(\"        ESTOP0\");     // Uncomment for debugging purposes\n   }\r\n\r\n   // DIVSEL MUST be 0 before PLLCR can be changed from\r\n   // 0x0000. It is set to 0 by an external reset XRSn\r\n   // This puts us in 1/4\r\n   if (SysCtrlRegs.PLLSTS.bit.DIVSEL != 0)\r\n   {\r\n       EALLOW;\r\n       SysCtrlRegs.PLLSTS.bit.DIVSEL = 0;\r\n       EDIS;\r\n   }\r\n\r\n   // Change the PLLCR\r\n   if (SysCtrlRegs.PLLCR.bit.DIV != val)\r\n   {\r\n\r\n      EALLOW;\r\n      // Before setting PLLCR turn off missing clock detect logic\r\n      SysCtrlRegs.PLLSTS.bit.MCLKOFF = 1;\r\n      SysCtrlRegs.PLLCR.bit.DIV = val;\r\n      EDIS;\r\n\r\n      // Optional: Wait for PLL to lock.\r\n      // During this time the CPU will switch to OSCCLK/2 until\r\n      // the PLL is stable.  Once the PLL is stable the CPU will\r\n      // switch to the new PLL value.\r\n      //\r\n      // This time-to-lock is monitored by a PLL lock counter.\r\n      //\r\n      // Code is not required to sit and wait for the PLL to lock.\r\n      // However, if the code does anything that is timing critical,\r\n      // and requires the correct clock be locked, then it is best to\r\n      // wait until this switching has completed.\r\n\r\n      // Wait for the PLL lock bit to be set.\r\n\r\n      // The watchdog should be disabled before this loop, or fed within\r\n      // the loop via ServiceDog().\r\n\r\n      // Uncomment to disable the watchdog\r\n      DisableDog();\r\n\r\n      while(SysCtrlRegs.PLLSTS.bit.PLLLOCKS != 1)\r\n      {\r\n          // Uncomment to service the watchdog\r\n          // ServiceDog();\r\n      }\r\n\r\n      EALLOW;\r\n      SysCtrlRegs.PLLSTS.bit.MCLKOFF = 0;\r\n      EDIS;\r\n    }\r\n\r\n    // If switching to 1/2\r\n    if((divsel == 1)||(divsel == 2))\r\n    {\r\n        EALLOW;\r\n        SysCtrlRegs.PLLSTS.bit.DIVSEL = divsel;\r\n        EDIS;\r\n    }\r\n\r\n    // If switching to 1/1\r\n    // * First go to 1/2 and let the power settle\r\n    //   The time required will depend on the system, this is only an example\r\n    // * Then switch to 1/1\r\n    if(divsel == 3)\r\n    {\r\n        EALLOW;\r\n        SysCtrlRegs.PLLSTS.bit.DIVSEL = 2;\r\n        DELAY_US(50L);\r\n        SysCtrlRegs.PLLSTS.bit.DIVSEL = 3;\r\n        EDIS;\r\n    }\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n// Example: InitPll2:\r\n//---------------------------------------------------------------------------\r\n// This function initializes the PLL2 registers.\r\n\r\nvoid InitPll2(Uint16 clksrc, Uint16 pllmult, Uint16 clkdiv)\r\n{\r\n      EALLOW;\r\n      \r\n      // Check if SYSCLK2DIV2DIS is in /2 mode\r\n      if(DevEmuRegs.DEVICECNF.bit.SYSCLK2DIV2DIS != 0)\r\n      {\r\n      \tDevEmuRegs.DEVICECNF.bit.SYSCLK2DIV2DIS = 0;\r\n      }\r\n      \r\n      // Enable PLL2\r\n      SysCtrlRegs.PLL2CTL.bit.PLL2EN = 1;\r\n      // Select clock source for PLL2\r\n      SysCtrlRegs.PLL2CTL.bit.PLL2CLKSRCSEL = clksrc;\r\n      // Set PLL2 Multiplier\r\n      SysCtrlRegs.PLL2MULT.bit.PLL2MULT = pllmult;\r\n      \r\n      // Wait for PLL to lock.\r\n      // Uncomment to disable the watchdog\r\n\t  DisableDog();\r\n      while(SysCtrlRegs.PLL2STS.bit.PLL2LOCKS!= 1)\r\n      {\r\n      \t// Uncomment to service the watchdog\r\n        // ServiceDog();\r\n      }\r\n            \r\n      // Set System Clock 2 divider\r\n      DevEmuRegs.DEVICECNF.bit.SYSCLK2DIV2DIS = clkdiv;\r\n      EDIS;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Example: InitPeripheralClocks:\r\n//---------------------------------------------------------------------------\r\n// This function initializes the clocks to the peripheral modules.\r\n// First the high and low clock prescalers are set\r\n// Second the clocks are enabled to each peripheral.\r\n// To reduce power, leave clocks to unused peripherals disabled\r\n//\r\n// Note: If a peripherals clock is not enabled then you cannot\r\n// read or write to the registers for that peripheral\r\n\r\nvoid InitPeripheralClocks(void)\r\n{\r\n   EALLOW;\r\n\r\n// LOSPCP prescale register settings, normally it will be set to default values\r\n\r\n// GpioCtrlRegs.GPAMUX2.bit.GPIO18 = 3;  // GPIO18 = XCLKOUT\r\n   SysCtrlRegs.LOSPCP.all = 0x0002;\r\n\r\n// XCLKOUT to SYSCLKOUT ratio.  By default XCLKOUT = 1/4 SYSCLKOUT\r\n   SysCtrlRegs.XCLK.bit.XCLKOUTDIV=2;\r\n\r\n// Peripheral clock enables set for the selected peripherals.\r\n// If you are not using a peripheral leave the clock off\r\n// to save on power.\r\n//\r\n// Note: not all peripherals are available on all F2806x derivates.\r\n// Refer to the datasheet for your particular device.\r\n//\r\n// This function is not written to be an example of efficient code.\r\n\r\n   SysCtrlRegs.PCLKCR1.bit.EPWM1ENCLK = 1;    // ePWM1\r\n   SysCtrlRegs.PCLKCR1.bit.EPWM2ENCLK = 1;    // ePWM2\r\n   SysCtrlRegs.PCLKCR1.bit.EPWM3ENCLK = 1;    // ePWM3\r\n   SysCtrlRegs.PCLKCR1.bit.EPWM4ENCLK = 1;    // ePWM4\r\n   SysCtrlRegs.PCLKCR1.bit.EPWM5ENCLK = 1;    // ePWM5\r\n   SysCtrlRegs.PCLKCR1.bit.EPWM6ENCLK = 1;    // ePWM6\r\n   SysCtrlRegs.PCLKCR1.bit.EPWM7ENCLK = 1;    // ePWM7\r\n   SysCtrlRegs.PCLKCR1.bit.EPWM8ENCLK = 1;    // ePWM8\r\n\r\n   SysCtrlRegs.PCLKCR0.bit.HRPWMENCLK = 1;    // HRPWM\r\n   SysCtrlRegs.PCLKCR0.bit.TBCLKSYNC = 1;     // Enable TBCLK within the ePWM\r\n\r\n   SysCtrlRegs.PCLKCR1.bit.EQEP1ENCLK = 1;    // eQEP1\r\n   SysCtrlRegs.PCLKCR1.bit.EQEP2ENCLK = 1;    // eQEP2\r\n\r\n   SysCtrlRegs.PCLKCR1.bit.ECAP1ENCLK = 1;    // eCAP1\r\n   SysCtrlRegs.PCLKCR1.bit.ECAP2ENCLK = 1;    // eCAP2\r\n   SysCtrlRegs.PCLKCR1.bit.ECAP3ENCLK = 1;    // eCAP3\r\n\r\n   SysCtrlRegs.PCLKCR2.bit.HRCAP1ENCLK = 1;\t  // HRCAP1\r\n   SysCtrlRegs.PCLKCR2.bit.HRCAP2ENCLK = 1;\t  // HRCAP2\r\n   SysCtrlRegs.PCLKCR2.bit.HRCAP3ENCLK = 1;\t  // HRCAP3\r\n   SysCtrlRegs.PCLKCR2.bit.HRCAP4ENCLK = 1;   // HRCAP4\r\n\r\n   SysCtrlRegs.PCLKCR0.bit.ADCENCLK = 1;      // ADC\r\n   SysCtrlRegs.PCLKCR3.bit.COMP1ENCLK = 1;    // COMP1\r\n   SysCtrlRegs.PCLKCR3.bit.COMP2ENCLK = 1;    // COMP2\r\n   SysCtrlRegs.PCLKCR3.bit.COMP3ENCLK = 1;    // COMP3\r\n\r\n   SysCtrlRegs.PCLKCR3.bit.CPUTIMER0ENCLK = 1; // CPU Timer 0\r\n   SysCtrlRegs.PCLKCR3.bit.CPUTIMER1ENCLK = 1; // CPU Timer 1\r\n   SysCtrlRegs.PCLKCR3.bit.CPUTIMER2ENCLK = 1; // CPU Timer 2\r\n\r\n   SysCtrlRegs.PCLKCR3.bit.DMAENCLK = 1;      // DMA\r\n\r\n   SysCtrlRegs.PCLKCR3.bit.CLA1ENCLK = 1;     // CLA1\r\n\r\n   SysCtrlRegs.PCLKCR3.bit.USB0ENCLK = 1;\t  // USB0 \r\n   \r\n   SysCtrlRegs.PCLKCR0.bit.I2CAENCLK = 1;     // I2C-A\r\n   SysCtrlRegs.PCLKCR0.bit.SPIAENCLK = 1;     // SPI-A\r\n   SysCtrlRegs.PCLKCR0.bit.SPIBENCLK = 1;     // SPI-B\r\n   SysCtrlRegs.PCLKCR0.bit.SCIAENCLK = 1;     // SCI-A\r\n   SysCtrlRegs.PCLKCR0.bit.SCIBENCLK = 1;     // SCI-B\r\n   SysCtrlRegs.PCLKCR0.bit.MCBSPAENCLK = 1;   // McBSP-A\r\n   SysCtrlRegs.PCLKCR0.bit.ECANAENCLK=1;      // eCAN-A\r\n   \r\n   SysCtrlRegs.PCLKCR0.bit.TBCLKSYNC = 1;     // Enable TBCLK within the ePWM\r\n\r\n   EDIS;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n// Example: CsmUnlock:\r\n//---------------------------------------------------------------------------\r\n// This function unlocks the CSM. User must replace 0xFFFF's with current\r\n// password for the DSP. Returns 1 if unlock is successful.\r\n\r\n#define STATUS_FAIL          0\r\n#define STATUS_SUCCESS       1\r\n\r\nUint16 CsmUnlock()\r\n{\r\n    volatile Uint16 temp;\r\n\r\n    // Load the key registers with the current password. The 0xFFFF's are dummy\r\n    // passwords.  User should replace them with the correct password for the DSP.\r\n\r\n    EALLOW;\r\n    CsmRegs.KEY0 = 0xFFFF;\r\n    CsmRegs.KEY1 = 0xFFFF;\r\n    CsmRegs.KEY2 = 0xFFFF;\r\n    CsmRegs.KEY3 = 0xFFFF;\r\n    CsmRegs.KEY4 = 0xFFFF;\r\n    CsmRegs.KEY5 = 0xFFFF;\r\n    CsmRegs.KEY6 = 0xFFFF;\r\n    CsmRegs.KEY7 = 0xFFFF;\r\n    EDIS;\r\n\r\n    // Perform a dummy read of the password locations\r\n    // if they match the key values, the CSM will unlock\r\n\r\n    temp = CsmPwl.PSWD0;\r\n    temp = CsmPwl.PSWD1;\r\n    temp = CsmPwl.PSWD2;\r\n    temp = CsmPwl.PSWD3;\r\n    temp = CsmPwl.PSWD4;\r\n    temp = CsmPwl.PSWD5;\r\n    temp = CsmPwl.PSWD6;\r\n    temp = CsmPwl.PSWD7;\r\n\r\n    // If the CSM unlocked, return succes, otherwise return\r\n    // failure.\r\n    if (CsmRegs.CSMSCR.bit.SECURE == 0) return STATUS_SUCCESS;\r\n    else return STATUS_FAIL;\r\n\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n// Example: IntOsc1Sel:\r\n//---------------------------------------------------------------------------\r\n// This function switches to Internal Oscillator 1 and turns off all other clock\r\n// sources to minimize power consumption\r\n\r\nvoid IntOsc1Sel (void) {\r\n    EALLOW;\r\n    SysCtrlRegs.CLKCTL.bit.INTOSC1OFF = 0;\r\n    SysCtrlRegs.CLKCTL.bit.OSCCLKSRCSEL=0;  // Clk Src = INTOSC1\r\n    SysCtrlRegs.CLKCTL.bit.XCLKINOFF=1;     // Turn off XCLKIN\r\n    SysCtrlRegs.CLKCTL.bit.XTALOSCOFF=1;    // Turn off XTALOSC\r\n    SysCtrlRegs.CLKCTL.bit.INTOSC2OFF=1;    // Turn off INTOSC2\r\n    EDIS;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n// Example: IntOsc2Sel:\r\n//---------------------------------------------------------------------------\r\n// This function switches to Internal oscillator 2 from External Oscillator\r\n// and turns off all other clock sources to minimize power consumption\r\n// NOTE: If there is no external clock connection, when switching from\r\n//       INTOSC1 to INTOSC2, EXTOSC and XLCKIN must be turned OFF prior\r\n//       to switching to internal oscillator 1\r\n\r\nvoid IntOsc2Sel (void) {\r\n    EALLOW;\r\n    SysCtrlRegs.CLKCTL.bit.INTOSC2OFF = 0;     // Turn on INTOSC2\r\n    SysCtrlRegs.CLKCTL.bit.OSCCLKSRC2SEL = 1;  // Switch to INTOSC2\r\n    SysCtrlRegs.CLKCTL.bit.XCLKINOFF = 1;      // Turn off XCLKIN\r\n    SysCtrlRegs.CLKCTL.bit.XTALOSCOFF = 1;     // Turn off XTALOSC\r\n    SysCtrlRegs.CLKCTL.bit.OSCCLKSRCSEL = 1;   // Switch to Internal Oscillator 2\r\n    SysCtrlRegs.CLKCTL.bit.WDCLKSRCSEL = 0;    // Clock Watchdog off of INTOSC1 always\r\n    SysCtrlRegs.CLKCTL.bit.INTOSC1OFF = 0;     // Leave INTOSC1 on\r\n    EDIS;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n// Example: XtalOscSel:\r\n//---------------------------------------------------------------------------\r\n// This function switches to External CRYSTAL oscillator and turns off all other clock\r\n// sources to minimize power consumption. This option may not be available on all\r\n// device packages\r\n\r\nvoid XtalOscSel (void)  {\r\n     EALLOW;\r\n     SysCtrlRegs.CLKCTL.bit.XTALOSCOFF = 0;     // Turn on XTALOSC\n     DELAY_US(1000);                            // Wait for 1ms while XTAL starts up\n     SysCtrlRegs.CLKCTL.bit.XCLKINOFF = 1;      // Turn off XCLKIN\r\n     SysCtrlRegs.CLKCTL.bit.OSCCLKSRC2SEL = 0;  // Switch to external clock\r\n     SysCtrlRegs.CLKCTL.bit.OSCCLKSRCSEL = 1;   // Switch from INTOSC1 to INTOSC2/ext clk\r\n     SysCtrlRegs.CLKCTL.bit.WDCLKSRCSEL = 0;    // Clock Watchdog off of INTOSC1 always\r\n     SysCtrlRegs.CLKCTL.bit.INTOSC2OFF = 1;     // Turn off INTOSC2\r\n     SysCtrlRegs.CLKCTL.bit.INTOSC1OFF = 0;     // Leave INTOSC1 on\r\n     EDIS;\r\n}\r\n\r\n\r\n//---------------------------------------------------------------------------\r\n// Example: ExtOscSel:\r\n//---------------------------------------------------------------------------\r\n// This function switches to External oscillator and turns off all other clock\r\n// sources to minimize power consumption.\r\n\r\nvoid ExtOscSel (void)  {\r\n     EALLOW;\r\n     SysCtrlRegs.XCLK.bit.XCLKINSEL = 1;       // 1-GPIO19 = XCLKIN, 0-GPIO38 = XCLKIN\r\n     SysCtrlRegs.CLKCTL.bit.XTALOSCOFF = 1;    // Turn on XTALOSC\r\n     SysCtrlRegs.CLKCTL.bit.XCLKINOFF = 0;     // Turn on XCLKIN\r\n     SysCtrlRegs.CLKCTL.bit.OSCCLKSRC2SEL = 0; // Switch to external clock\r\n     SysCtrlRegs.CLKCTL.bit.OSCCLKSRCSEL = 1;  // Switch from INTOSC1 to INTOSC2/ext clk\r\n     SysCtrlRegs.CLKCTL.bit.WDCLKSRCSEL = 0;   // Clock Watchdog off of INTOSC1 always\r\n     SysCtrlRegs.CLKCTL.bit.INTOSC2OFF = 1;    // Turn off INTOSC2\r\n     SysCtrlRegs.CLKCTL.bit.INTOSC1OFF = 0;     // Leave INTOSC1 on\r\n     EDIS;\r\n}\r\n\r\n\r\n\r\n//===========================================================================\r\n// End of file.\r\n//===========================================================================\r\n"},{"name":"F2806x_usDelay.asm","type":"other","group":"legacy","path":"C:\\Users\\rodri\\git\\bruno\\mbd-elevator\\matlab\\controller_base_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ti\\controlSUITE\\device_support\\f2806x\\v151\\F2806x_common\\source","tag":"","groupDisplay":"Other files","code":";//###########################################################################\r\n;//\r\n;// FILE:  F2806x_usDelay.asm\r\n;//\r\n;// TITLE: Simple delay function\r\n;//\r\n;// DESCRIPTION:\r\n;//  \r\n;// This is a simple delay function that can be used to insert a specified\r\n;// delay into code.  \r\n;// \r\n;// This function is only accurate if executed from internal zero-waitstate\r\n;// SARAM. If it is executed from waitstate memory then the delay will be\r\n;// longer then specified. \r\n;// \r\n;// To use this function:\r\n;//\r\n;//  1 - update the CPU clock speed in the F2806x_Examples.h\r\n;//    file. For example:\r\n;//    #define CPU_RATE 12.500L // for an 80MHz CPU clock speed\r\n;//\r\n;//  2 - Call this function by using the DELAY_US(A) macro\r\n;//    that is defined in the F2806x_Examples.h file.  This macro\r\n;//    will convert the number of microseconds specified\r\n;//    into a loop count for use with this function.  \r\n;//    This count will be based on the CPU frequency you specify.\r\n;//\r\n;//  3 - For the most accurate delay \r\n;//    - Execute this function in 0 waitstate RAM.  \r\n;//    - Disable interrupts before calling the function\r\n;//      If you do not disable interrupts, then think of\r\n;//      this as an \"at least\" delay function as the actual\r\n;//      delay may be longer. \r\n;//\r\n;//  The C assembly call from the DELAY_US(time) macro will\r\n;//  look as follows: \r\n;//\r\n;//  extern void Delay(long LoopCount);                \r\n;//\r\n;//        MOV   AL,#LowLoopCount\r\n;//        MOV   AH,#HighLoopCount\r\n;//        LCR   _Delay\r\n;//\r\n;//  Or as follows (if count is less then 16-bits):\r\n;//\r\n;//        MOV   ACC,#LoopCount\r\n;//        LCR   _Delay\r\n;//\r\n;//\r\n;//###########################################################################\r\n;// $TI Release: F2806x C/C++ Header Files and Peripheral Examples V151 $ \r\n;// $Release Date: February  2, 2016 $ \r\n;// $Copyright: Copyright (C) 2011-2016 Texas Instruments Incorporated -\n;//             http://www.ti.com/ ALL RIGHTS RESERVED $\n;//###########################################################################\t\r\n\r\n;//\r\n;//  *IMPORTANT*\r\n;//  IF RUNNING FROM FLASH, PLEASE COPY OVER THE SECTION \"ramfuncs\"  FROM FLASH\r\n;//  TO RAM PRIOR TO CALLING InitSysCtrl(). THIS PREVENTS THE MCU FROM THROWING AN EXCEPTION\r\n;//  WHEN A CALL TO DELAY_US() IS MADE. \r\n;//\r\n       .def _DSP28x_usDelay\r\n       .sect \"ramfuncs\"\r\n\r\n        .global  __DSP28x_usDelay\r\n_DSP28x_usDelay:\r\n        SUB    ACC,#1\r\n        BF     _DSP28x_usDelay,GEQ    ;; Loop if ACC >= 0\r\n        LRETR \r\n\r\n;There is a 9/10 cycle overhead and each loop\r\n;takes five cycles. The LoopCount is given by\r\n;the following formula:\r\n;  DELAY_CPU_CYCLES = 9 + 5*LoopCount\r\n; LoopCount = (DELAY_CPU_CYCLES - 9) / 5\r\n; The macro DELAY_US(A) performs this calculation for you\r\n;\r\n;//===========================================================================\r\n;// End of file.\r\n;//===========================================================================\r\n"},{"name":"MW_c28xGPIO.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2024a\\toolbox\\c2b\\tic2000_shared\\src","tag":"","groupDisplay":"Other files","code":"/*####################################################\n * FILE: MW_c28xGPIO.c\n * TITLE: GPIO functions to access the GPIO specific registers for C2000 target\n * Copyright 2017-2023 The MathWorks, Inc.\n * ####################################################*/\n\n/* ***************************************************************************/\n/* the includes */\n\n#include \"MW_c28xGPIO.h\"\n#ifdef CPU2\n#ifdef MW_F2837XD\n#include \"MW_f2837xD_includes.h\"\n#endif //MW_F2837XD\n#ifdef MW_F2838X\n#include \"MW_f2838x_includes.h\"\n#endif //MW_F2838X\n#ifdef MW_F28P65X\n#include \"MW_f28p65x_includes.h\"\n#endif //MW_F28P65X\n#endif //CPU2\n\n/* ***************************************************************************/\n/* the defines */\n\n/* ***************************************************************************/\n/* the globals */\n\nUint16 GPIO_oneTimeInit = 0;\n\n/* ***************************************************************************/\n/* the functions*/\n\n/* One time initialization of all GPIOs */\nvoid OneTimeGpioInit(void)\n{    \n    if(GPIO_oneTimeInit == 0U)\n    {\n#ifdef CPU1\n        InitGpio();\n#endif //End of CPU1\n        GPIO_oneTimeInit = 1U;\n    }\n}\n\n#ifndef MW_F281X /*GPIO implementation not supported for C281x */\n#ifndef F2837X_REG_FORMAT /*GPIO functions are provided by TI*/\n#ifndef MW_F2804X /*GPIO initialization is provided by TI for F2804x*/\n\n/*Sets all pins to be muxed to GPIO in input mode with pull-ups enabled.\n * Also sets the qualification to synchronous.*/\nvoid InitGpio(void)\n{\n    volatile Uint32 *gpioBaseAddr;\n    Uint16 regOffset;\n    EALLOW;\n    /*Fill all registers with zeros. Writing to each register separately\n     * for all GPIO modules would make this function *very* long. Fortunately,\n     * we'd be writing them all with zeros anyway, so this saves a lot of space.*/\n    gpioBaseAddr = (Uint32 *)&GpioCtrlRegs;\n    for (regOffset = 0U; regOffset < sizeof(GpioCtrlRegs)/2; regOffset++)\n    {\n        /*Hack to avoid enabling pull-ups on all pins. GPyPUD is offset\n         * 0x0C in each register group of 0x40 words. Since this is a\n         * 32-bit pointer, the addresses must be divided by 2.*/\n        if (regOffset % (0x10/2) != (0x0C/2))\n        {\n            gpioBaseAddr[regOffset] = 0x00000000U;\n        }\n    }\n    \n    gpioBaseAddr = (Uint32 *)&GpioDataRegs;\n    for (regOffset = 0; regOffset < sizeof(GpioDataRegs)/2; regOffset++)\n    {\n        gpioBaseAddr[regOffset] = 0x00000000U;\n    }\n    \n    /* For concerto additional registers needs to be initialized*/\n    #ifdef MW_PIL_TIC2000_CONCERTO\n    /*Fill all registers with zeros. Writing to each register separately\n     * for all GPIO modules would make this function *very* long. Fortunately,\n     * we'd be writing them all with zeros anyway, so this saves a lot of space.*/\n    gpioBaseAddr = (Uint32 *)&GpioG1CtrlRegs;\n    for (regOffset = 0U; regOffset < sizeof(GpioG1CtrlRegs)/2; regOffset++)\n    {\n        /*Hack to avoid enabling pull-ups on all pins. GPyPUD is offset\n         * 0x0C in each register group of 0x40 words. Since this is a\n         * 32-bit pointer, the addresses must be divided by 2.*/\n        if (regOffset % (0x10/2) != (0x0C/2))\n        {\n            gpioBaseAddr[regOffset] = 0x00000000U;\n        }\n    }\n    \n    gpioBaseAddr = (Uint32 *)&GpioG1DataRegs;\n    for (regOffset = 0U; regOffset < sizeof(GpioG1DataRegs)/2; regOffset++)\n    {\n        gpioBaseAddr[regOffset] = 0x00000000U;\n    }\n    #endif //End of MW_PIL_TIC2000_CONCERTO\n    EDIS;\n}\n#endif // End of MW_F2804X\n\n/*Set the peripheral muxing for the specified pin.\n * The appropriate parameters can be found in the GPIO Muxed Pins table.\n * Use the GPIO index row (0 to 4) to select a muxing option for the GPIO.*/\nvoid GPIO_SetupPinMux(Uint16 pin, Uint16 cpu, Uint16 peripheral)\n{\n    volatile Uint32 *gpioBaseAddr;\n    volatile Uint32 *mux;\n    Uint16 pin32, pin16;\n    \n    pin32 = pin % 32;\n    pin16 = pin % 16;\n    #ifdef MW_PIL_TIC2000_CONCERTO\n    if (pin >= 128U)\n    {\n        #ifdef F28M36x_DEVICE_H\n        if (pin <= 135U)\n        {\n            gpioBaseAddr = (Uint32 *)&GpioCtrlRegs;\n        }\n        else if (pin >=192U && pin <= 199U)\n        {\n            gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (0x1080/2);\n        }\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        if (pin <= 135U)\n        {\n            gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (0x1000/2);\n        }\n        #endif //End of F28M35x_DEVICE_H\n    }\n    else\n    {\n        #ifdef F28M36x_DEVICE_H\n        gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (0x80/2) + (pin/32)*GPY_CTRL_OFFSET;\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (pin/32)*GPY_CTRL_OFFSET;\n        #endif //End of F28M35x_DEVICE_H\n    }\n    #else\n    gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (pin/32)*GPY_CTRL_OFFSET;\n    #endif // End of MW_PIL_TIC2000_CONCERTO\n    \n    /*Sanity check for valid peripheral values*/\n    if (peripheral > 0x4)\n    {\n        return;\n    }\n    /*Create pointers to the appropriate registers. This is a workaround\n     * for the way GPIO registers are defined. The standard definition\n     * in the header file makes it very easy to do named accesses of one\n     * register or bit, but hard to do arbitrary numerical accesses. It's\n     * easier to have an array of GPIO modules with identical registers,\n     * including arrays for multi-register groups like GPyCSEL1-4. But\n     * the header file doesn't define anything we can turn into an array,\n     * so manual pointer arithmetic is used instead.*/\n    mux = gpioBaseAddr + GPYMUX + pin32/16;\n    \n    //Now for the actual function\n    EALLOW;\n    \n    /* Unfortunately, since we don't know the pin in\n     * advance we can't hardcode a bitfield reference, so there's some tricky\n     * bit twiddling here.*/\n    *mux &= ~(0x3UL << (2*pin16));\n    *mux |= (Uint32)(peripheral & 0x3UL) << (2*pin16);\n    \n    //WARNING: This code does not touch the analog mode select registers,\n    //which are needed to give the USB module control of its IOs.\n    EDIS;\n}\n\n/*Setup up the GPIO input/output options for the specified pin.\n * The flags are a 16-bit mask produced by ORing together options.\n * For input pins, the valid flags are:\n * GPIO_PULLUP    Enable pull-up\n * GPIO_SYNC        Synchronize the input latch to PLLSYSCLK (default -- you don't need to specify this)\n * GPIO_QUAL3    Use 3-sample qualification\n * GPIO_QUAL6    Use 6-sample qualification\n * GPIO_ASYNC    Do not use synchronization or qualification\n * (Note: only one of SYNC, QUAL3, QUAL6, or ASYNC is allowed)\n * For output pins, the valid flags are:\n * GPIO_PULLUP        If open drain enabled, also enable the pull-up\n * and the input qualification flags (SYNC/QUAL3/QUAL6/SYNC) listed above.\n * With no flags, the default input state is synchronous with no pull-up or polarity inversion.\n * The default output state is the standard digital output.*/\nvoid GPIO_SetupPinOptions(Uint16 pin, Uint16 output, Uint16 flags)\n{\n    {\n    volatile Uint32 *gpioBaseAddr;\n    volatile Uint32 *dir, *pud, *qsel;\n    Uint32 pin32, pin16, pinMask, qual;\n    \n    pin32 = pin % 32;\n    pin16 = pin % 16;\n    pinMask = 1UL << pin32;\n    #ifdef MW_PIL_TIC2000_CONCERTO\n    if (pin >= 128U)\n    {\n        #ifdef F28M36x_DEVICE_H\n        if (pin <= 135U)\n        {\n            gpioBaseAddr = (Uint32 *)&GpioCtrlRegs;\n        }\n        else if (pin >=192U && pin <= 199U)\n        {\n            gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (0x1080/2);\n        }\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        if (pin <= 135U)\n        {\n            gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (0x1000/2);\n        }\n        #endif //End of F28M35x_DEVICE_H\n    }\n    else\n    {\n        #ifdef F28M36x_DEVICE_H\n        gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (0x80/2) + (pin/32)*GPY_CTRL_OFFSET;\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (pin/32)*GPY_CTRL_OFFSET;\n        #endif //End of F28M35x_DEVICE_H\n    }\n    #else\n    gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (pin/32)*GPY_CTRL_OFFSET;\n    #endif // End of MW_PIL_TIC2000_CONCERTO\n    \n    /*Create pointers to the appropriate registers. This is a workaround\n     * for the way GPIO registers are defined. The standard definition\n     * in the header file makes it very easy to do named accesses of one\n     * register or bit, but hard to do arbitrary numerical accesses. It's\n     * easier to have an array of GPIO modules with identical registers,\n     * including arrays for multi-register groups like GPyQSEL1-2. But\n     * the header file doesn't define anything we can turn into an array,\n     * so manual pointer arithmetic is used instead.*/\n    dir = gpioBaseAddr + GPYDIR;\n    pud = gpioBaseAddr + GPYPUD;\n    qsel = gpioBaseAddr + GPYQSEL + pin32/16;\n    \n    EALLOW;\n    \n    /*Set the data direction*/\n    *dir &= ~pinMask;\n    if (output == 1U)\n    {\n        /*Output, with optional open drain mode and pull-up*/\n        *dir |= pinMask;\n        \n        /*Enable pull-up if necessary. Open drain mode must be active.*/\n        if (flags & GPIO_PULLUP){\n            *pud &= ~pinMask;\n        }\n        else{\n            *pud |= pinMask;\n        }\n    } else\n    {\n        /*Input, with optional pull-up, qualification, and polarity inversion*/\n        *dir &= ~pinMask;\n        \n        /*Enable pull-up if necessary*/\n        if (flags & GPIO_PULLUP){\n            *pud &= ~pinMask;\n        }\n        else{\n            *pud |= pinMask;\n        }\n    }\n    \n    /*Extract the qualification parameter and load it into the register. This is\n     * also needed for open drain outputs, so we might as well do it all the time.*/\n    qual = (flags & GPIO_ASYNC) / GPIO_QUAL3;\n    *qsel &= ~(0x3L << (2 * pin16));\n    if (qual != 0x0){\n        *qsel |= qual << (2 * pin16);\n    }\n    \n    EDIS;\n    }\n}\n\n/*Read the GPyDAT register bit for the specified pin.\n * Note that this returns the actual state of the pin, not the state of the output latch.*/\nUint16 GPIO_ReadPin(Uint16 pin)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint16 pinVal;\n\n    #ifdef MW_PIL_TIC2000_CONCERTO\n    if (pin >= 128U)\n    {\n        #ifdef F28M36x_DEVICE_H\n        if (pin <= 135U)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x40/2);\n        }\n        else if (pin >=192U && pin <= 199U)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x10C0/2);\n        }\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        if (pin <= 135U)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x1000/2);\n        }\n        #endif //End of F28M35x_DEVICE_H\n    }\n    else\n    {\n        #ifdef F28M36x_DEVICE_H\n        gpioDataReg = (Uint32 *)&GpioDataRegs + (0xC0/2) + (pin/32)*GPY_DATA_OFFSET;\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        gpioDataReg = (Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n        #endif //End of F28M35x_DEVICE_H\n    }\n    #else\n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n    #endif // End of MW_PIL_TIC2000_CONCERTO\n    pinVal = (gpioDataReg[GPYDAT] >> (pin % 32)) & 0x1;\n    \n    return pinVal;\n}\n\n/*Set the GPyDAT register bit for the specified pin.*/\nvoid GPIO_WritePin(Uint16 pin, Uint16 outVal)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint32 pinMask;\n    \n    #ifdef MW_PIL_TIC2000_CONCERTO\n    if (pin >= 128U)\n    {\n        #ifdef F28M36x_DEVICE_H\n        if (pin <= 135U)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x40/2);\n        }\n        else if (pin >=192U && pin <= 199U)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x10C0/2);\n        }\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        if (pin <= 135U)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x1000/2);\n        }\n        #endif //End of F28M35x_DEVICE_H\n    }\n    else\n    {\n        #ifdef F28M36x_DEVICE_H\n        gpioDataReg = (Uint32 *)&GpioDataRegs + (0xC0/2) + (pin/32)*GPY_DATA_OFFSET;\n        #endif //End of F28M36x_DEVICE_H\n\n        #ifdef F28M35x_DEVICE_H\n        gpioDataReg = (Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n        #endif //End of F28M35x_DEVICE_H\n    }\n    #else\n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n    #endif // End of MW_PIL_TIC2000_CONCERTO\n    pinMask = 1UL << (pin % 32);\n    \n    if (outVal == 0U){        \n        gpioDataReg[GPYCLEAR] = pinMask;\n    }\n    else{\n        gpioDataReg[GPYSET] = pinMask;\n    }\n}\n\n/*Toggle the GPyDAT register bit for the specified pin.*/\nvoid GPIO_TogglePin(Uint16 pin)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint32 pinMask;\n    \n    #ifdef MW_PIL_TIC2000_CONCERTO\n    if (pin >= 128U)\n    {\n        #ifdef F28M36x_DEVICE_H\n        if (pin <= 135U)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x40/2);\n        }\n        else if (pin >=192U && pin <= 199U)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x10C0/2);\n        }\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        if (pin <= 135U)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x1000/2);\n        }\n        #endif //End of F28M35x_DEVICE_H\n    }\n    else\n    {\n        #ifdef F28M36x_DEVICE_H\n        gpioDataReg = (Uint32 *)&GpioDataRegs + (0xC0/2) + (pin/32)*GPY_DATA_OFFSET;\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        gpioDataReg = (Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n        #endif //End of F28M35x_DEVICE_H\n    }\n    #else\n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n    #endif // End of MW_PIL_TIC2000_CONCERTO\n    pinMask = 1UL << (pin % 32);\n    \n    \n    gpioDataReg[GPYTOGGLE] = pinMask;\n\n}\n\n#else // for F2837X_REG_FORMAT\n#if defined(MW_F2838X) \n#if defined(CPU1)\n\nvoid InitGpio(void)\n{\n    volatile Uint32 *gpioBaseAddr;\n    Uint16 regOffset;\n\n    /*Disable pin locks*/\n    EALLOW;\n    GpioCtrlRegs.GPALOCK.all = 0x00000000U;\n    GpioCtrlRegs.GPBLOCK.all = 0x00000000U;\n    GpioCtrlRegs.GPCLOCK.all = 0x00000000U;\n    GpioCtrlRegs.GPDLOCK.all = 0x00000000U;\n    GpioCtrlRegs.GPELOCK.all = 0x00000000U;\n    GpioCtrlRegs.GPFLOCK.all = 0x00000000U;\n\n    /* Fill all registers with zeros. Writing to each register separately\n     * for six GPIO modules would make this function *very* long.\n     * Fortunately, we'd be writing them all with zeros anyway, so this\n     * saves a lot of space.*/\n    gpioBaseAddr = (Uint32 *)&GpioCtrlRegs;\n    for (regOffset = 0U; regOffset < sizeof(GpioCtrlRegs)/2; regOffset++)\n    {\n        /* Hack to avoid enabling pull-ups on all pins. GPyPUD is offset\n         * 0x0C in each register group of 0x40 words. Since this is a\n         * 32-bit pointer, the addresses must be divided by 2.*/\n        if (regOffset % (0x40/2) != (0x0C/2))\n        {\n            gpioBaseAddr[regOffset] = 0x00000000U;\n        }\n    }\n\n    gpioBaseAddr = (Uint32 *)&GpioDataRegs;\n    for (regOffset = 0U; regOffset < sizeof(GpioDataRegs)/2; regOffset++)\n    {\n        gpioBaseAddr[regOffset] = 0x00000000U;\n    }\n\n    EDIS;\n}\n\nvoid GPIO_SetupPinMux(Uint16 gpioNumber, Uint16 cpu, Uint16 muxPosition)\n{\n    volatile Uint32 *gpioBaseAddr;\n    volatile Uint32 *mux, *gmux, *csel;\n    Uint16 pin32, pin16, pin8;\n\n    pin32 = gpioNumber % 32;\n    pin16 = gpioNumber % 16;\n    pin8 = gpioNumber % 8;\n    gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (gpioNumber/32)*GPY_CTRL_OFFSET;\n\n    /*Sanity check for valid cpu and peripheral values*/\n    if (cpu > GPIO_MUX_CM || muxPosition > 0xF)\n        return;\n\n    /* Create pointers to the appropriate registers. This is a workaround\n     * for the way GPIO registers are defined. The standard definition\n     * in the header file makes it very easy to do named accesses of one\n     * register or bit, but hard to do arbitrary numerical accesses. It's\n     * easier to have an array of GPIO modules with identical registers,\n     * including arrays for multi-register groups like GPyCSEL1-4. But\n     * the header file doesn't define anything we can turn into an array,\n     * so manual pointer arithmetic is used instead.*/\n    mux = gpioBaseAddr + GPYMUX + pin32/16;\n    gmux = gpioBaseAddr + GPYGMUX + pin32/16;\n    csel = gpioBaseAddr + GPYCSEL + pin32/8;\n\n    /* Now for the actual function */\n    EALLOW;\n\n    /* To change the muxing, set the peripheral mux to 0/GPIO first to avoid\n     * glitches, then change the group mux, then set the peripheral mux to\n     * its target value. Finally, set the CPU select. This procedure is\n     * described in the TRM. Unfortunately, since we don't know the pin in\n     * advance we can't hardcode a bitfield reference, so there's some\n     * tricky bit twiddling here.*/\n    *mux &= ~(0x3UL << (2*pin16));\n    *gmux &= ~(0x3UL << (2*pin16));\n    *gmux |= (Uint32)((muxPosition >> 2) & 0x3UL) << (2*pin16);\n    *mux |= (Uint32)(muxPosition & 0x3UL) << (2*pin16);\n\n    *csel &= ~(0x7L << (4*pin8));\n    *csel |= (Uint32)(cpu & 0x7L) << (4*pin8);\n\n    /* WARNING: This code does not touch the analog mode select registers,\n     * which are needed to give the USB module control of its IOs.*/\n    EDIS;\n}\n\nvoid GPIO_SetupPinOptions(Uint16 gpioNumber, Uint16 output, Uint16 flags)\n{\n    volatile Uint32 *gpioBaseAddr;\n    volatile Uint32 *dir, *pud, *inv, *odr, *qsel;\n    Uint32 pin32, pin16, pinMask, qual;\n\n    pin32 = gpioNumber % 32;\n    pin16 = gpioNumber % 16;\n    pinMask = 1UL << pin32;\n    gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (gpioNumber/32)*GPY_CTRL_OFFSET;\n\n    /* Create pointers to the appropriate registers. This is a workaround\n     * for the way GPIO registers are defined. The standard definition\n     * in the header file makes it very easy to do named accesses of one\n     * register or bit, but hard to do arbitrary numerical accesses. It's\n     * easier to have an array of GPIO modules with identical registers,\n     * including arrays for multi-register groups like GPyQSEL1-4. But\n     * the header file doesn't define anything we can turn into an array,\n     * so manual pointer arithmetic is used instead.*/\n    dir = gpioBaseAddr + GPYDIR;\n    pud = gpioBaseAddr + GPYPUD;\n    inv = gpioBaseAddr + GPYINV;\n    odr = gpioBaseAddr + GPYODR;\n    qsel = gpioBaseAddr + GPYQSEL + pin32/16;\n\n    EALLOW;\n\n    /*Set the data direction*/\n    *dir &= ~pinMask;\n    if (output == 1)\n    {        \n        /* Output, with optional open drain mode and pull-up */        \n        *dir |= pinMask;\n\n        /* Enable open drain if necessary */\n        if (flags & GPIO_OPENDRAIN)\n        {\n            *odr |= pinMask;\n        }\n        else\n        {\n            *odr &= ~pinMask;\n        }\n\n        /* Enable pull-up if necessary. Open drain mode must be active. */\n        if (flags & (GPIO_OPENDRAIN | GPIO_PULLUP))\n        {\n            *pud &= ~pinMask;\n        }\n        else\n        {\n            *pud |= pinMask;\n        }\n    }\n    else\n    {\n        /* Input, with optional pull-up, qualification, and polarity\n         * inversion */\n        *dir &= ~pinMask;\n\n        /* Enable pull-up if necessary */\n        if (flags & GPIO_PULLUP)\n        {\n            *pud &= ~pinMask;\n        }\n        else\n        {\n            *pud |= pinMask;\n        }\n\n        /* Invert polarity if necessary */\n        if (flags & GPIO_INVERT)\n        {\n            *inv |= pinMask;\n        }\n        else\n        {\n            *inv &= ~pinMask;\n        }\n    }\n\n    /* Extract the qualification parameter and load it into the register.\n     * This is also needed for open drain outputs, so we might as well do it\n     * all the time. */\n    qual = (flags & GPIO_ASYNC) / GPIO_QUAL3;\n    *qsel &= ~(0x3L << (2 * pin16));\n    if (qual != 0x0)\n    {\n        *qsel |= qual << (2 * pin16);\n    }\n\n    EDIS;\n}\n\nvoid GPIO_EnableUnbondedIOPullupsFor176Pin(void)\n{\n\tEALLOW;\n\tGpioCtrlRegs.GPCPUD.all = ~0x80000000U;  /* GPIO 95 */\n\tGpioCtrlRegs.GPDPUD.all = ~0xFFFFFFF7U;  /* GPIOs 96-127 */\n\tGpioCtrlRegs.GPEPUD.all = ~0xFFFFFFDFU;  /* GPIOs 128-159 except for 133 */\n\tGpioCtrlRegs.GPFPUD.all = ~0x000001FFU;  /* GPIOs 160-168 */\n\tEDIS;\n}\n\nvoid GPIO_EnableUnbondedIOPullupsFor100Pin(void)\n{\n    EALLOW;\n    GpioCtrlRegs.GPAPUD.all = ~0xFFC003E3U;  //GPIOs 0-1, 5-9, 22-31\n    GpioCtrlRegs.GPBPUD.all = ~0x03FFF1FFU;  //GPIOs 32-40, 44-57\n    GpioCtrlRegs.GPCPUD.all = ~0xE10FBC18U;  //GPIOs 67-68, 74-77, 79-83, 93-95\n    GpioCtrlRegs.GPDPUD.all = ~0xFFFFFFF7U;  //GPIOs 96-127\n    GpioCtrlRegs.GPEPUD.all = ~0xFFFFFFFFU;  //GPIOs 128-159\n    GpioCtrlRegs.GPFPUD.all = ~0x000001FFU;  //GPIOs 160-168\n    EDIS;\n}\n\nvoid GPIO_EnableUnbondedIOPullups(void)\n{\n\t/* bits 8-10 have pin count */\n    unsigned char pin_count = ((DevCfgRegs.PARTIDL.all & 0x00000700U) >> 8U) ;\n\n\t/* 5 = 100 pin\n\t * 6 = 176 pin\n\t * 7 = 337 pin */\n    if(pin_count == 5)\n    {\n        GPIO_EnableUnbondedIOPullupsFor100Pin();\n    }\n    else if (pin_count == 6)\n\t{\n\t\tGPIO_EnableUnbondedIOPullupsFor176Pin();\n\t}\n\telse\n\t{\n\t\t/* do nothing - this is 337 pin package */\n\t}\n}\n#endif // defined(CPU1)\n/*Read the GPyDAT register bit for the specified pin.\n * Note that this returns the actual state of the pin, not the state of the output latch.*/\nUint16 GPIO_ReadPin(Uint16 pin)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint16 pinVal;\n\n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n    pinVal = (gpioDataReg[GPYDAT] >> (pin % 32)) & 0x1U;\n    \n    return pinVal;\n}\n\n/*Set the GPyDAT register bit for the specified pin.*/\nvoid GPIO_WritePin(Uint16 pin, Uint16 outVal)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint32 pinMask;\n    \n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n    pinMask = 1UL << (pin % 32);\n    \n    if (outVal == 0U)\n    {\n        gpioDataReg[GPYCLEAR] = pinMask;\n    }\n    else\n    {\n        gpioDataReg[GPYSET] = pinMask;\n    }\n}\n\n#endif // end of defined(MW_F2838X)\n\n/*Toggle the GPyDAT register bit for the specified pin.*/\nvoid GPIO_TogglePin(Uint16 pin)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint32 pinMask;    \n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + ((pin/32)*GPY_DATA_OFFSET);\n    Uint32 temp = (1UL << (pin % 32U));\n    pinMask = (Uint32)temp;\n    gpioDataReg[GPYTOGGLE] = pinMask;\n}\n#endif // end of F2837X_REG_FORMAT\n\n/*Set the GPIO pin. Set the mux values and pin options for the specified pin.\n  This function can be used for all processors except C281x. The implementation is dependant on CPU1 and CPU2*/ \nvoid Set_GPIOPin(Uint16 pin, Uint16 cpu, Uint16 peripheral, Uint16 output, Uint16 flags)\n{\n#if defined(F2837X_REG_FORMAT) && defined(CPU2)\n    Uint32 *pulMsgRam = (void *)CPU01_TO_CPU02_PASSMSG;\n    Uint32 gpioData = 0x00000000;\n    //Sanity check for valid cpu and peripheral values\n    #ifdef MW_F28P65X\n        if (peripheral > 0xFU)\n            return;\n    #else\n        if (cpu > GPIO_MUX_CPU2CLA || peripheral > 0xFU)\n            return;\n    #endif\n    gpioData = gpioData | pin;\n    gpioData = gpioData | ((Uint32)peripheral << 8U);\n    gpioData = gpioData | ((Uint32)output << 16U);\n    gpioData = gpioData | ((Uint32)flags << 24U);\n    #ifdef MW_F2837XD\n    Uint32 ulRWord32 = 0;\n    IPCLiteLtoRFunctionCall(IPC_FLAG0, pulMsgRam[0], gpioData, IPC_FLAG31);\n    while (IPCLiteLtoRGetResult(&ulRWord32,IPC_LENGTH_32_BITS,\n            IPC_FLAG31) != STATUS_PASS)\n    {\n    }\n    #else\n     MW_IPC_sendCommand(IPC_CPU2_L_CPU1_R, (IPC_FLAG0 | IPC_FLAG31), IPC_ADDR_CORRECTION_DISABLE, IPC_FUNC_CALL, pulMsgRam[0], gpioData);\n    IPC_waitForAck(IPC_CPU2_L_CPU1_R, IPC_FLAG31);\n    IPC_getResponse(IPC_CPU2_L_CPU1_R);\n    #endif //MW_F2837XD\n#else\n    GPIO_SetupPinMux(pin, cpu, peripheral);\n    GPIO_SetupPinOptions(pin, output, flags);\n#endif // end of defined(F2837X_REG_FORMAT) && defined(CPU2)\n}\n#endif //end of MW_F281X\n    \n"},{"name":"MW_c28xGlobalInterrupts.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2024a\\toolbox\\c2b\\tic2000_shared\\src","tag":"","groupDisplay":"Other files","code":"/*####################################################\n * FILE: MW_c28xGlobalInterrupts.c\n * TITLE: Common board support functions specific for C2000 targets\n * Copyright 2020-2022 The MathWorks, Inc.\n * ####################################################*/\n\n/* ***************************************************************************/\n/* the includes */\n#include \"MW_target_hardware_resources.h\"\n\n/* ***************************************************************************/\n/* the globals */\nvolatile int16_T MW_InterruptDisableLock = 0;\n\n\n/* ***************************************************************************/\n/* the functions*/\n\n/* Global interrupt enable function */\nvoid globalInterruptEnable(void)\n{\n    if (0 == MW_InterruptDisableLock)\n    {\n        /* Enabled the interrupts only if it was enabled before */\n        __enable_interrupts(); /* Enable Global Interrupt INTM and realtime interrupt DBGM */\n    }\n    --MW_InterruptDisableLock;\n    if (0 > MW_InterruptDisableLock)\n    {\n        MW_InterruptDisableLock = 0;\n    }\n}\n\n/* Global interrupt disable function */\nvoid globalInterruptDisable(void)\n{\n    /* Disable Global Interrupt INTM using __disable_interrupts()\n     The function will return 0 if interrupt was enabled previously\n     otherwise it will return 1 if the interrupt was previously disabled*/\n    MW_InterruptDisableLock += ((__disable_interrupts()) & 0x01);\n}\n"},{"name":"MW_c28xx_board.c","type":"source","group":"legacy","path":"C:\\Users\\rodri\\git\\bruno\\mbd-elevator\\matlab\\controller_base_ert_rtw","tag":"","groupDisplay":"Other files","code":"#include \"c2000BoardSupport.h\"\r\n#include \"F2806x_Device.h\"\r\n#include \"F2806x_Examples.h\"\r\n#include \"F2806x_GlobalPrototypes.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"controller_base.h\"\r\n#include \"controller_base_private.h\"\r\n\r\nvoid init_board (void)\r\n{\r\n  DisableDog();\r\n  EALLOW;\r\n  SysCtrlRegs.PCLKCR0.bit.ADCENCLK = 1U;/* Enable ADC peripheral clock*/\r\n  (*Device_cal)();\r\n  SysCtrlRegs.PCLKCR0.bit.ADCENCLK = 0U;/* Return ADC clock to original state*/\r\n  EDIS;\r\n\r\n  /* Select Internal Oscillator 1 as Clock Source (default), and turn off all unused clocks to\r\n   * conserve power.\r\n   */\r\n  IntOsc1Sel();\r\n\r\n  /* Initialize the PLL control: PLLCR and DIVSEL\r\n   * DSP28_PLLCR and DSP28_DIVSEL are defined in DSP2806x_Examples.h\r\n   */\r\n  InitPll(9,3);\r\n  InitPeripheralClocks();\r\n  EALLOW;\r\n\r\n  /* Configure low speed peripheral clocks */\r\n  SysCtrlRegs.LOSPCP.all = 0U;\r\n  EDIS;\r\n\r\n  /* Disable and clear all CPU interrupts */\r\n  DINT;\r\n  IER = 0x0000U;\r\n  IFR = 0x0000U;\r\n  InitPieCtrl();\r\n  InitPieVectTable();\r\n  InitCpuTimers();\r\n\r\n#ifdef CPU1\r\n#endif                                 // #ifdef CPU1\r\n\r\n  /* initial GPIO qualification settings.... */\r\n  EALLOW;\r\n  GpioCtrlRegs.GPAQSEL1.all = 0x0U;\r\n  GpioCtrlRegs.GPAQSEL2.all = 0x0U;\r\n  GpioCtrlRegs.GPBQSEL1.all = 0x0U;\r\n  GpioCtrlRegs.GPBQSEL2.all = 0x0U;\r\n  EDIS;\r\n}\r\n"},{"name":"MW_c28xx_csl.c","type":"source","group":"legacy","path":"C:\\Users\\rodri\\git\\bruno\\mbd-elevator\\matlab\\controller_base_ert_rtw","tag":"","groupDisplay":"Other files","code":"#include \"c2000BoardSupport.h\"\r\n#include \"F2806x_Device.h\"\r\n#include \"F2806x_Examples.h\"\r\n#include \"F2806x_GlobalPrototypes.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"controller_base.h\"\r\n#include \"controller_base_private.h\"\r\n\r\nvoid enableExtInterrupt (void);\r\nvoid configureGPIOExtInterrupt(void);\r\n\r\n#include <stdint.h>\r\n\r\nvoid disableWatchdog(void)\r\n{\r\n  int *WatchdogWDCR = (int *)(uintptr_t)0x7029;\r\n  asm(\" EALLOW \");\r\n  *WatchdogWDCR = 0x0068;\r\n  asm(\" EDIS \");\r\n}\r\n"},{"name":"MW_c28xx_pie.h","type":"header","group":"other","path":"C:\\Users\\rodri\\git\\bruno\\mbd-elevator\\matlab\\controller_base_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef __MW_C28XX_PIE_H__\r\n#define __MW_C28XX_PIE_H__\r\n#define PIEMASK0                       64\r\n#define IFRMASK                        1\r\n#endif                                 /* MW_C28XX_PIE_H */\r\n"},{"name":"MW_target_hardware_resources.h","type":"header","group":"other","path":"C:\\Users\\rodri\\git\\bruno\\mbd-elevator\\matlab\\controller_base_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef PORTABLE_WORDSIZES\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#ifndef __MW_TARGET_HARDWARE_RESOURCES_H__\n#define __MW_TARGET_HARDWARE_RESOURCES_H__\n\n#define MW_MULTI_TASKING_MODE 1\n#include \"c2000BoardSupport.h\"\n#include \"F2806x_Device.h\"\n#include \"F2806x_Examples.h\"\n#include \"F2806x_GlobalPrototypes.h\"\n#include \"F2806x_CpuTimers.h\"\n#include \"HCCal_Type0_V1.h\"\n#include \"c2000SchedulerTimer.h\"\n\n#define MW_USECODERTARGET 1\n#define MW_TARGETHARDWARE TI Piccolo F28069M LaunchPad\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERSIZE 1000\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERNUM 3\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_MAXCONTIGSAMPLES 8\n#define MW_EXTMODEPROTOCOLINFO_XCPONCAN_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_XCPONCAN_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_XCPONCAN_LOGGINGBUFFERSIZE 1000\n#define MW_EXTMODEPROTOCOLINFO_XCPONCAN_LOGGINGBUFFERNUM 3\n#define MW_EXTMODEPROTOCOLINFO_XCPONCAN_MAXCONTIGSAMPLES 10\n#define MW_CONNECTIONINFO_XCPONSERIAL_BAUDRATE codertarget.registry.getExtModeHostBaud(hCS);\n#define MW_CONNECTIONINFO_XCPONSERIAL_COMPORT codertarget.registry.serialPortValueCallback(hCS, 'ExtModeCOMPort');\n#define MW_CONNECTIONINFO_XCPONSERIAL_VERBOSE 1\n#define MW_CONNECTIONINFO_XCPONCAN_CANVENDOR \n#define MW_CONNECTIONINFO_XCPONCAN_CANDEVICE \n#define MW_CONNECTIONINFO_XCPONCAN_CANCHANNEL \n#define MW_CONNECTIONINFO_XCPONCAN_BUSSPEED codertarget.registry.getExtModeCANBusSpeed(hCS)\n#define MW_CONNECTIONINFO_XCPONCAN_CANIDCOMMAND 2\n#define MW_CONNECTIONINFO_XCPONCAN_CANIDRESPONSE 3\n#define MW_CONNECTIONINFO_XCPONCAN_ISCANIDEXTENDED 0\n#define MW_CONNECTIONINFO_XCPONCAN_VERBOSE 1\n#define MW_EXTMODE_CONFIGURATION XCP on Serial\n#define MW_EXTMODE_CANMODULE 0\n#define MW_EXTMODE_CANRXMAILBOXNUMBER 0\n#define MW_EXTMODE_CANTXMAILBOXNUMBER 1\n#define MW_EXTMODE_SCIMODULE 0\n#define MW_EXTMODE_USEREALTIMESTAMPLOGGING 0\n#define MW_EXTMODE_SIGNALBUFFERSIZE 2000.000000\n#define MW_ESB_PROCESSINGUNIT c28xCPU1\n#define MW_ESB_SIMDIAGSHOWINSDI 1\n#define MW_ESB_SIMDIAGSAVETOFILE 1\n#define MW_ESB_SIMDIAGOVERWRITEFILE 0\n#define MW_ESB_HWDIAGSHOWINSDI 0\n#define MW_ESB_HWDIAGSAVETOFILE 0\n#define MW_ESB_HWDIAGOVERWRITEFILE 0\n#define MW_ESB_HWDIAGINSTRUMENTATION Code\n#define MW_ESB_HWDIAGRECORDING Continuous\n#define MW_ESB_HWDIAGSTREAMINGMODETYPE Unlimited\n#define MW_ESB_HWDIAGBUFFERSIZE 1024.000000\n#define MW_ESB_HWDIAGNUMBUFFERS 1.000000\n#define MW_ESB_HWDIAGVIEWLEVEL Task manager tasks\n#define MW_ESB_SETRNG 0\n#define MW_ESB_RNGSEED default\n#define MW_ESB_CACHEDATA 0\n#define MW_ESB_SCHEDULEEDITORSCHEDULERESET 0\n#define MW_FPGADESIGN_PROJECTFOLDER soc_prj\n#define MW_RTOS Baremetal\n#define MW_SCHEDULER_INTERRUPT_SOURCE 0\n#define MW_RUNTIME_BUILDACTION 1\n#define MW_RUNTIME_DISABLEPARALLELBUILD 0\n#define MW_RUNTIME_DEVICEID 0\n#define MW_RUNTIME_FLASHLOAD 1\n#define MW_RUNTIME_BOOTLOADERPROGRAMMINGSUPPORT 0\n#define MW_RUNTIME_BOOTLOADERCHOICE 0\n#define MW_RUNTIME_BOOTLOADERCOMPORT COM1\n#define MW_RUNTIME_LOADCOMMANDARG $(TARGET_ROOT)/CCS_Config/f28069.ccxml\n#define MW_RUNTIME_DMAACCESS 0\n#define MW_RUNTIME_BOOTLOADERCOMPATIBLEOS 1\n#define MW_RUNTIME_ENABLEFASTRTS 1\n#define MW_TARGETLINKOBJ_USECUSTOMLINKER 0\n#define MW_TARGETLINKOBJ_NAME $(TARGET_ROOT)/src/c28069M.cmd\n#define MW_CLOCKING_CPUCLOCKRATEMHZ 90\n#define MW_CLOCKING_USEINTERNALOSC 1\n#define MW_CLOCKING_OSCCLK 10\n#define MW_CLOCKING_AUTOSETPLLSETTINGS 1\n#define MW_CLOCKING_PLLCR 9\n#define MW_CLOCKING_DIVSEL 2\n#define MW_CLOCKING_CLOSESTCPUCLOCK 90\n#define MW_CLOCKING_LSPCLKDIV 0\n#define MW_CLOCKING_LSPCLK 90\n#define MW_CLOCKING_PLL2MULT 11\n#define MW_CLOCKING_PLL2CLK 120\n#define MW_ADC_CLOCKDIV 1\n#define MW_ADC_CLOCKFREQUENCY 45.000000\n#define MW_ADC_NONOVERLAP 0\n#define MW_ADC_OFFSETCORRECTIONVALUE AdcRegs.ADCOFFTRIM.bit.OFFTRIM\n#define MW_ADC_EXTERNALREFERENCESELECTOR 0\n#define MW_ADC_EXTERNALREFERENCEVREFHI 3.3\n#define MW_ADC_EXTERNALREFERENCEVREFLO 0\n#define MW_ADC_INTPULSEGENERATION 0\n#define MW_ADC_SOCPRIORITY 0\n#define MW_ADC_XINT2GPIO 0\n#define MW_COMP_PINASSIGNMENT_COMP1 1\n#define MW_COMP_PINASSIGNMENT_COMP2 1\n#define MW_COMP_PINASSIGNMENT_COMP3 1\n#define MW_ECAN_A_MODULECLOCKFREQUENCY 45\n#define MW_ECAN_A_BAUDRATEPRESCALER 5.000000\n#define MW_ECAN_A_TSEG1 3\n#define MW_ECAN_A_TSEG2 1\n#define MW_ECAN_A_BAUDRATE 1000000\n#define MW_ECAN_A_SBG 0\n#define MW_ECAN_A_SJW 1\n#define MW_ECAN_A_SAM 0\n#define MW_ECAN_A_ENHANCEDCANMODE 1\n#define MW_ECAN_A_SELFTESTMODE 0\n#define MW_ECAP_PINASSIGNMENT_ECAP1 3\n#define MW_ECAP_PINASSIGNMENT_ECAP2 1\n#define MW_ECAP_PINASSIGNMENT_ECAP3 1\n#define MW_HRCAP_HRCAP1 0\n#define MW_HRCAP_HRCAP2 1\n#define MW_HRCAP_HRCAP3 0\n#define MW_HRCAP_HRCAP4 0\n#define MW_HRCAP_PINVALUE_HRCAP1 54\n#define MW_HRCAP_PINVALUE_HRCAP2 55\n#define MW_HRCAP_PINVALUE_HRCAP3 56\n#define MW_HRCAP_PINVALUE_HRCAP4 57\n#define MW_HRCAP_PINMUX_HRCAP1 3\n#define MW_HRCAP_PINMUX_HRCAP2 3\n#define MW_HRCAP_PINMUX_HRCAP3 3\n#define MW_HRCAP_PINMUX_HRCAP4 3\n#define MW_EPWM_PINASSIGNMENT_TZ1 0\n#define MW_EPWM_PINASSIGNMENT_TZ2 0\n#define MW_EPWM_PINASSIGNMENT_TZ3 0\n#define MW_EPWM_PINASSIGNMENT_SYNCI 0\n#define MW_EPWM_PINASSIGNMENT_SYNCO 0\n#define MW_EPWM_PINASSIGNMENT_PWM1A 0\n#define MW_EPWM_PINASSIGNMENT_PWM1B 0\n#define MW_EPWM_PINASSIGNMENT_PWM2A 0\n#define MW_EPWM_PINASSIGNMENT_PWM2B 0\n#define MW_EPWM_PINASSIGNMENT_PWM3A 0\n#define MW_EPWM_PINASSIGNMENT_PWM3B 0\n#define MW_EPWM_PINASSIGNMENT_PWM4A 0\n#define MW_EPWM_PINASSIGNMENT_PWM4B 0\n#define MW_EPWM_PINASSIGNMENT_PWM5A 0\n#define MW_EPWM_PINASSIGNMENT_PWM5B 0\n#define MW_EPWM_PINASSIGNMENT_PWM6A 0\n#define MW_EPWM_PINASSIGNMENT_PWM6B 0\n#define MW_EPWM_PINASSIGNMENT_PWM7A 2\n#define MW_EPWM_PINASSIGNMENT_PWM7B 1\n#define MW_EPWM_PINASSIGNMENT_PWM8A 2\n#define MW_EPWM_PINASSIGNMENT_PWM8B 0\n#define MW_I2C_MODE 0\n#define MW_I2C_ADDRDATAFORMAT 0\n#define MW_I2C_OWNADDRESS 1\n#define MW_I2C_BITCOUNT 0\n#define MW_I2C_MODULECLOCKPRESCALER 9\n#define MW_I2C_MODULECLOCKFREQUENCY 9000000\n#define MW_I2C_MASTERCLKLOWTIME 5\n#define MW_I2C_MASTERCLKHIGHTIME 5\n#define MW_I2C_MASTERCLOCKFREQUENCY 450000\n#define MW_I2C_MASTERCLOCKFREQUENCY_1 450000\n#define MW_I2C_MASTERCLOCKFREQUENCY_2 450000\n#define MW_I2C_ENABLELOOPBACK 0\n#define MW_I2C_PINASSIGNMENT_SDAA 0\n#define MW_I2C_PINASSIGNMENT_SCLA 0\n#define MW_I2C_PINVALUE_SDA 32\n#define MW_I2C_PINVALUE_SCL 33\n#define MW_I2C_PINMUX_SDA 1\n#define MW_I2C_PINMUX_SCL 1\n#define MW_I2C_ENABLETXINT 0\n#define MW_I2C_TXFIFOLEVEL 4\n#define MW_I2C_ENABLERXINT 0\n#define MW_I2C_RXFIFOLEVEL 4\n#define MW_I2C_ENABLESYSINT 0\n#define MW_I2C_AAS 0\n#define MW_I2C_SCD 0\n#define MW_I2C_ARDY 0\n#define MW_I2C_NACK 0\n#define MW_I2C_AL 0\n#define MW_SCI_A_ENABLELOOPBACK 0\n#define MW_SCI_A_SUSPENSIONMODE 2\n#define MW_SCI_A_NUMBEROFSTOPBITS 0\n#define MW_SCI_A_PARITYMODE 0\n#define MW_SCI_A_CHARACTERLENGTHBITS 0\n#define MW_SCI_A_USERBAUDRATE 5.625e6\n#define MW_SCI_A_BAUDRATEPRESCALER 1.000000\n#define MW_SCI_A_BAUDRATE 5625000.000000\n#define MW_SCI_A_ENABLEINTERRUPTTX 0\n#define MW_SCI_A_FIFOINTERRUPTLEVELTX 1\n#define MW_SCI_A_ENABLEINTERRUPTRX 0\n#define MW_SCI_A_FIFOINTERRUPTLEVELRX 1\n#define MW_SCI_A_COMMUNICATIONMODE 0\n#define MW_SCI_A_BLOCKINGMODE 0\n#define MW_SCI_A_DATABYTEORDER 0\n#define MW_SCI_A_DATASWAPWIDTH 0\n#define MW_SCI_A_PINASSIGNMENT_TX 2\n#define MW_SCI_A_PINASSIGNMENT_RX 2\n#define MW_SCI_B_ENABLELOOPBACK 0\n#define MW_SCI_B_SUSPENSIONMODE 2\n#define MW_SCI_B_NUMBEROFSTOPBITS 0\n#define MW_SCI_B_PARITYMODE 0\n#define MW_SCI_B_CHARACTERLENGTHBITS 0\n#define MW_SCI_B_USERBAUDRATE 115200\n#define MW_SCI_B_BAUDRATEPRESCALER 97.000000\n#define MW_SCI_B_BAUDRATE 114796.000000\n#define MW_SCI_B_ENABLEINTERRUPTTX 0\n#define MW_SCI_B_FIFOINTERRUPTLEVELTX 1\n#define MW_SCI_B_ENABLEINTERRUPTRX 0\n#define MW_SCI_B_FIFOINTERRUPTLEVELRX 1\n#define MW_SCI_B_COMMUNICATIONMODE 0\n#define MW_SCI_B_BLOCKINGMODE 0\n#define MW_SCI_B_DATABYTEORDER 0\n#define MW_SCI_B_DATASWAPWIDTH 0\n#define MW_SCI_B_PINASSIGNMENT_TX 6\n#define MW_SCI_B_PINASSIGNMENT_RX 2\n#define MW_SPI_A_MODE 0\n#define MW_SPI_A_USERBAUDRATE 921600\n#define MW_SPI_A_BAUDRATEFACTOR 97.000000\n#define MW_SPI_A_BAUDRATE 918367.000000\n#define MW_SPI_A_DATABITS 15\n#define MW_SPI_A_CLOCKPOLARITY 0\n#define MW_SPI_A_CLOCKPHASE 0\n#define MW_SPI_A_SUSPENSIONMODE 2\n#define MW_SPI_A_ENABLELOOPBACK 0\n#define MW_SPI_A_ENABLETHREEWIRE 0\n#define MW_SPI_A_TXINTERRUPTENABLE 0\n#define MW_SPI_A_FIFOINTERRUPTLEVEL_TX 0\n#define MW_SPI_A_RXINTERRUPTENABLE 0\n#define MW_SPI_A_FIFOINTERRUPTLEVEL_RX 4\n#define MW_SPI_A_FIFOENABLE 1\n#define MW_SPI_A_FIFOTRANSMITDELAY 0\n#define MW_SPI_A_PINASSIGNMENT_SIMO 2\n#define MW_SPI_A_PINASSIGNMENT_SOMI 2\n#define MW_SPI_A_PINASSIGNMENT_CLK 1\n#define MW_SPI_A_PINASSIGNMENT_STE 1\n#define MW_SPI_A_PINVALUE_SIMO 16\n#define MW_SPI_A_PINVALUE_SOMI 17\n#define MW_SPI_A_PINVALUE_CLK 18\n#define MW_SPI_A_PINVALUE_STE 19\n#define MW_SPI_A_PINMUX_SIMO 1\n#define MW_SPI_A_PINMUX_SOMI 1\n#define MW_SPI_A_PINMUX_CLK 1\n#define MW_SPI_A_PINMUX_STE 1\n#define MW_SPI_A_FIFO_LEVEL 4.000000\n#define MW_SPI_B_MODE 0\n#define MW_SPI_B_USERBAUDRATE 921600\n#define MW_SPI_B_BAUDRATEFACTOR 97.000000\n#define MW_SPI_B_BAUDRATE 918367.000000\n#define MW_SPI_B_DATABITS 15\n#define MW_SPI_B_CLOCKPOLARITY 0\n#define MW_SPI_B_CLOCKPHASE 0\n#define MW_SPI_B_SUSPENSIONMODE 2\n#define MW_SPI_B_ENABLELOOPBACK 0\n#define MW_SPI_B_ENABLETHREEWIRE 0\n#define MW_SPI_B_TXINTERRUPTENABLE 0\n#define MW_SPI_B_FIFOINTERRUPTLEVEL_TX 0\n#define MW_SPI_B_RXINTERRUPTENABLE 0\n#define MW_SPI_B_FIFOINTERRUPTLEVEL_RX 4\n#define MW_SPI_B_FIFOENABLE 1\n#define MW_SPI_B_FIFOTRANSMITDELAY 0\n#define MW_SPI_B_PINASSIGNMENT_SIMO 2\n#define MW_SPI_B_PINASSIGNMENT_SOMI 2\n#define MW_SPI_B_PINASSIGNMENT_CLK 1\n#define MW_SPI_B_PINASSIGNMENT_STE 2\n#define MW_SPI_B_PINVALUE_SIMO 24\n#define MW_SPI_B_PINVALUE_SOMI 25\n#define MW_SPI_B_PINVALUE_CLK 14\n#define MW_SPI_B_PINVALUE_STE 27\n#define MW_SPI_B_PINMUX_SIMO 3\n#define MW_SPI_B_PINMUX_SOMI 3\n#define MW_SPI_B_PINMUX_CLK 3\n#define MW_SPI_B_PINMUX_STE 3\n#define MW_SPI_B_FIFO_LEVEL 4.000000\n#define MW_EQEP_PINASSIGNMENT_EQEP1A 1\n#define MW_EQEP_PINASSIGNMENT_EQEP1B 1\n#define MW_EQEP_PINASSIGNMENT_EQEP1S 0\n#define MW_EQEP_PINASSIGNMENT_EQEP1I 1\n#define MW_EQEP_PINASSIGNMENT_EQEP2A 2\n#define MW_EQEP_PINASSIGNMENT_EQEP2B 2\n#define MW_EQEP_PINASSIGNMENT_EQEP2S 0\n#define MW_EQEP_PINASSIGNMENT_EQEP2I 3\n#define MW_WATCHDOG_ENABLE_WATCHDOG 0\n#define MW_WATCHDOG_WATCHDOGCLOCK 0\n#define MW_WATCHDOG_TIME_PERIOD 0.013107\n#define MW_WATCHDOG_WATCHDOGEVENT 0\n#define MW_GPIO0_7_GPIOQUALSEL0 0\n#define MW_GPIO0_7_GPIOQUALSEL1 0\n#define MW_GPIO0_7_GPIOQUALSEL2 0\n#define MW_GPIO0_7_GPIOQUALSEL3 0\n#define MW_GPIO0_7_GPIOQUALSEL4 0\n#define MW_GPIO0_7_GPIOQUALSEL5 0\n#define MW_GPIO0_7_GPIOQUALSEL6 0\n#define MW_GPIO0_7_GPIOQUALSEL7 0\n#define MW_GPIO0_7_QUALPRD 0\n#define MW_GPIO8_15_GPIOQUALSEL8 0\n#define MW_GPIO8_15_GPIOQUALSEL9 0\n#define MW_GPIO8_15_GPIOQUALSEL10 0\n#define MW_GPIO8_15_GPIOQUALSEL11 0\n#define MW_GPIO8_15_GPIOQUALSEL12 0\n#define MW_GPIO8_15_GPIOQUALSEL13 0\n#define MW_GPIO8_15_GPIOQUALSEL14 0\n#define MW_GPIO8_15_GPIOQUALSEL15 0\n#define MW_GPIO8_15_QUALPRD 0\n#define MW_GPIO16_23_GPIOQUALSEL16 0\n#define MW_GPIO16_23_GPIOQUALSEL17 0\n#define MW_GPIO16_23_GPIOQUALSEL18 0\n#define MW_GPIO16_23_GPIOQUALSEL19 0\n#define MW_GPIO16_23_GPIOQUALSEL20 0\n#define MW_GPIO16_23_GPIOQUALSEL21 0\n#define MW_GPIO16_23_GPIOQUALSEL22 0\n#define MW_GPIO16_23_GPIOQUALSEL23 0\n#define MW_GPIO16_23_QUALPRD 0\n#define MW_GPIO24_31_GPIOQUALSEL24 0\n#define MW_GPIO24_31_GPIOQUALSEL25 0\n#define MW_GPIO24_31_GPIOQUALSEL26 0\n#define MW_GPIO24_31_GPIOQUALSEL27 0\n#define MW_GPIO24_31_GPIOQUALSEL28 0\n#define MW_GPIO24_31_GPIOQUALSEL29 0\n#define MW_GPIO24_31_GPIOQUALSEL30 0\n#define MW_GPIO24_31_GPIOQUALSEL31 0\n#define MW_GPIO24_31_QUALPRD 0\n#define MW_GPIO32_39_GPIOQUALSEL32 0\n#define MW_GPIO32_39_GPIOQUALSEL33 0\n#define MW_GPIO32_39_GPIOQUALSEL34 0\n#define MW_GPIO32_39_GPIOQUALSEL39 0\n#define MW_GPIO32_39_QUALPRD 0\n#define MW_GPIO40_44_GPIOQUALSEL40 0\n#define MW_GPIO40_44_GPIOQUALSEL41 0\n#define MW_GPIO40_44_GPIOQUALSEL42 0\n#define MW_GPIO40_44_GPIOQUALSEL43 0\n#define MW_GPIO40_44_GPIOQUALSEL44 0\n#define MW_GPIO40_44_QUALPRD 0\n#define MW_GPIO50_55_GPIOQUALSEL50 0\n#define MW_GPIO50_55_GPIOQUALSEL51 0\n#define MW_GPIO50_55_GPIOQUALSEL52 0\n#define MW_GPIO50_55_GPIOQUALSEL53 0\n#define MW_GPIO50_55_GPIOQUALSEL54 0\n#define MW_GPIO50_55_GPIOQUALSEL55 0\n#define MW_GPIO50_55_QUALPRD 0\n#define MW_GPIO56_58_GPIOQUALSEL56 0\n#define MW_GPIO56_58_GPIOQUALSEL57 0\n#define MW_GPIO56_58_GPIOQUALSEL58 0\n#define MW_GPIO56_58_QUALPRD 0\n#define MW_DMA_CH1_ENABLEDMACHANNEL 0\n#define MW_DMA_CH1_DATASIZE 0\n#define MW_DMA_CH1_INTERRUPTSRC 0\n#define MW_DMA_CH1_EXTERNALPIN 0\n#define MW_DMA_CH1_BURSTSIZE 0\n#define MW_DMA_CH1_TRANSFERSIZE 1\n#define MW_DMA_CH1_SRCBEGINADD 0xC000\n#define MW_DMA_CH1_DSTBEGINADD 0xD000\n#define MW_DMA_CH1_SRCBURSTSTEP 0\n#define MW_DMA_CH1_DSTBURSTSTEP 0\n#define MW_DMA_CH1_SRCTRANSSTEP 0\n#define MW_DMA_CH1_DSTTRANSSTEP 0\n#define MW_DMA_CH1_WRAPSRCSIZE 65536\n#define MW_DMA_CH1_WRAPDSTSIZE 65536\n#define MW_DMA_CH1_SRCWRAPSTEP 0\n#define MW_DMA_CH1_DSTWRAPSTEP 0\n#define MW_DMA_CH1_SETCH1TOHIGH 0\n#define MW_DMA_CH1_ENABLEONESHOT 0\n#define MW_DMA_CH1_ENABLECONTINUOUS 1\n#define MW_DMA_CH1_SYNCENABLE 0\n#define MW_DMA_CH1_ENABLEDSTSYNC 0\n#define MW_DMA_CH1_GENINTERRUPT 0\n#define MW_DMA_CH1_ENABLEOVERFLOW 0\n#define MW_DMA_CH2_ENABLEDMACHANNEL 0\n#define MW_DMA_CH2_DATASIZE 0\n#define MW_DMA_CH2_INTERRUPTSRC 0\n#define MW_DMA_CH2_EXTERNALPIN 0\n#define MW_DMA_CH2_BURSTSIZE 0\n#define MW_DMA_CH2_TRANSFERSIZE 1\n#define MW_DMA_CH2_SRCBEGINADD 0xC000\n#define MW_DMA_CH2_DSTBEGINADD 0xD000\n#define MW_DMA_CH2_SRCBURSTSTEP 0\n#define MW_DMA_CH2_DSTBURSTSTEP 0\n#define MW_DMA_CH2_SRCTRANSSTEP 0\n#define MW_DMA_CH2_DSTTRANSSTEP 0\n#define MW_DMA_CH2_WRAPSRCSIZE 65536\n#define MW_DMA_CH2_WRAPDSTSIZE 65536\n#define MW_DMA_CH2_SRCWRAPSTEP 0\n#define MW_DMA_CH2_DSTWRAPSTEP 0\n#define MW_DMA_CH2_ENABLEONESHOT 0\n#define MW_DMA_CH2_ENABLECONTINUOUS 1\n#define MW_DMA_CH2_SYNCENABLE 0\n#define MW_DMA_CH2_ENABLEDSTSYNC 0\n#define MW_DMA_CH2_GENINTERRUPT 0\n#define MW_DMA_CH2_ENABLEOVERFLOW 0\n#define MW_DMA_CH3_ENABLEDMACHANNEL 0\n#define MW_DMA_CH3_DATASIZE 0\n#define MW_DMA_CH3_INTERRUPTSRC 0\n#define MW_DMA_CH3_EXTERNALPIN 0\n#define MW_DMA_CH3_BURSTSIZE 0\n#define MW_DMA_CH3_TRANSFERSIZE 1\n#define MW_DMA_CH3_SRCBEGINADD 0xC000\n#define MW_DMA_CH3_DSTBEGINADD 0xD000\n#define MW_DMA_CH3_SRCBURSTSTEP 0\n#define MW_DMA_CH3_DSTBURSTSTEP 0\n#define MW_DMA_CH3_SRCTRANSSTEP 0\n#define MW_DMA_CH3_DSTTRANSSTEP 0\n#define MW_DMA_CH3_WRAPSRCSIZE 65536\n#define MW_DMA_CH3_WRAPDSTSIZE 65536\n#define MW_DMA_CH3_SRCWRAPSTEP 0\n#define MW_DMA_CH3_DSTWRAPSTEP 0\n#define MW_DMA_CH3_ENABLEONESHOT 0\n#define MW_DMA_CH3_ENABLECONTINUOUS 1\n#define MW_DMA_CH3_SYNCENABLE 0\n#define MW_DMA_CH3_ENABLEDSTSYNC 0\n#define MW_DMA_CH3_GENINTERRUPT 0\n#define MW_DMA_CH3_ENABLEOVERFLOW 0\n#define MW_DMA_CH4_ENABLEDMACHANNEL 0\n#define MW_DMA_CH4_DATASIZE 0\n#define MW_DMA_CH4_INTERRUPTSRC 0\n#define MW_DMA_CH4_EXTERNALPIN 0\n#define MW_DMA_CH4_BURSTSIZE 0\n#define MW_DMA_CH4_TRANSFERSIZE 1\n#define MW_DMA_CH4_SRCBEGINADD 0xC000\n#define MW_DMA_CH4_DSTBEGINADD 0xD000\n#define MW_DMA_CH4_SRCBURSTSTEP 0\n#define MW_DMA_CH4_DSTBURSTSTEP 0\n#define MW_DMA_CH4_SRCTRANSSTEP 0\n#define MW_DMA_CH4_DSTTRANSSTEP 0\n#define MW_DMA_CH4_WRAPSRCSIZE 65536\n#define MW_DMA_CH4_WRAPDSTSIZE 65536\n#define MW_DMA_CH4_SRCWRAPSTEP 0\n#define MW_DMA_CH4_DSTWRAPSTEP 0\n#define MW_DMA_CH4_ENABLEONESHOT 0\n#define MW_DMA_CH4_ENABLECONTINUOUS 1\n#define MW_DMA_CH4_SYNCENABLE 0\n#define MW_DMA_CH4_ENABLEDSTSYNC 0\n#define MW_DMA_CH4_GENINTERRUPT 0\n#define MW_DMA_CH4_ENABLEOVERFLOW 0\n#define MW_DMA_CH5_ENABLEDMACHANNEL 0\n#define MW_DMA_CH5_DATASIZE 0\n#define MW_DMA_CH5_INTERRUPTSRC 0\n#define MW_DMA_CH5_EXTERNALPIN 0\n#define MW_DMA_CH5_BURSTSIZE 0\n#define MW_DMA_CH5_TRANSFERSIZE 1\n#define MW_DMA_CH5_SRCBEGINADD 0xC000\n#define MW_DMA_CH5_DSTBEGINADD 0xD000\n#define MW_DMA_CH5_SRCBURSTSTEP 0\n#define MW_DMA_CH5_DSTBURSTSTEP 0\n#define MW_DMA_CH5_SRCTRANSSTEP 0\n#define MW_DMA_CH5_DSTTRANSSTEP 0\n#define MW_DMA_CH5_WRAPSRCSIZE 65536\n#define MW_DMA_CH5_WRAPDSTSIZE 65536\n#define MW_DMA_CH5_SRCWRAPSTEP 0\n#define MW_DMA_CH5_DSTWRAPSTEP 0\n#define MW_DMA_CH5_ENABLEONESHOT 0\n#define MW_DMA_CH5_ENABLECONTINUOUS 1\n#define MW_DMA_CH5_SYNCENABLE 0\n#define MW_DMA_CH5_ENABLEDSTSYNC 0\n#define MW_DMA_CH5_GENINTERRUPT 0\n#define MW_DMA_CH5_ENABLEOVERFLOW 0\n#define MW_DMA_CH6_ENABLEDMACHANNEL 0\n#define MW_DMA_CH6_DATASIZE 0\n#define MW_DMA_CH6_INTERRUPTSRC 0\n#define MW_DMA_CH6_EXTERNALPIN 0\n#define MW_DMA_CH6_BURSTSIZE 0\n#define MW_DMA_CH6_TRANSFERSIZE 1\n#define MW_DMA_CH6_SRCBEGINADD 0xC000\n#define MW_DMA_CH6_DSTBEGINADD 0xD000\n#define MW_DMA_CH6_SRCBURSTSTEP 0\n#define MW_DMA_CH6_DSTBURSTSTEP 0\n#define MW_DMA_CH6_SRCTRANSSTEP 0\n#define MW_DMA_CH6_DSTTRANSSTEP 0\n#define MW_DMA_CH6_WRAPSRCSIZE 65536\n#define MW_DMA_CH6_WRAPDSTSIZE 65536\n#define MW_DMA_CH6_SRCWRAPSTEP 0\n#define MW_DMA_CH6_DSTWRAPSTEP 0\n#define MW_DMA_CH6_ENABLEONESHOT 0\n#define MW_DMA_CH6_ENABLECONTINUOUS 1\n#define MW_DMA_CH6_SYNCENABLE 0\n#define MW_DMA_CH6_ENABLEDSTSYNC 0\n#define MW_DMA_CH6_GENINTERRUPT 0\n#define MW_DMA_CH6_ENABLEOVERFLOW 0\n#define MW_XINT_GPIOXINT1SEL 0\n#define MW_XINT_GPIOXINT2SEL 0\n#define MW_XINT_GPIOXINT3SEL 0\n#define MW_XINT_POLARITY1 0\n#define MW_XINT_POLARITY2 0\n#define MW_XINT_POLARITY3 0\n#define MW_PIL_COMMUNICATIONINTERFACE 0\n#define MW_PIL_SCIMODULE 0\n#define MW_PIL_COMPORT COM4\n#define MW_EXTMODECOMPORT -1\n#define MW_SIMULINKIO_COMMUNICATIONINTERFACE 0\n#define MW_SIMULINKIO_SCIMODULE 0\n#define MW_SIMULINKIO_MODELTRANSPORTDATAFCN codertarget.simulinkIO.tic2000.getModelTransportInfo\n#define MW_SIMULINKIO_SERVERDEPLOYFCN codertarget.simulinkIO.tic2000.updateServer\n#define MW_SIMULINKIO_COMPORT COM4\n#define MW_SDCARD_ENABLE 0\n#define MW_SDCARD_SPIMODULE 0\n#define MW_SDCARD_SPIBAUDRATE 1\n#define MW_OVERRUNDETECTION_ENABLE_OVERRUN_DETECTION 0\n#define MW_OVERRUNDETECTION_CHECK_GPIO_STATUS 1\n#define MW_OVERRUNDETECTION_DIGITAL_OUTPUT_TO_SET_ON_OVERRUN 34\n#define MW_OVERRUNDETECTION_GPIOMODE 0\n#define MW_OVERRUNDETECTION_CUSTOM_LOGIC 0\n#define MW_OVERRUNDETECTION_PIE_NUMBER 0\n#define MW_OVERRUNDETECTION_CPU_NUMBER 0\n#define MW_OVERRUNDETECTION_CUSTOM_FUNCTION c2000_OverrunFunction\n#define MW_IOBLOCKSMODE deployed\n#define MW_DATAVERSION 2016.02\n\n#endif /* __MW_TARGET_HARDWARE_RESOURCES_H__ */\n\n#endif\n\n#endif\n"},{"name":"blapp_support.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2024a\\toolbox\\c2b\\tic2000\\src","tag":"","groupDisplay":"Other files","code":"\n/*\n * Copyright 2016-2017 The MathWorks, Inc.\n */\n\n#include \"MW_target_hardware_resources.h\"\n#include \"rtwtypes.h\"\n\n/*\n *  Add conflict check for SCI when bootloader used\n *  UART ISR is already configured\n * TI- no need to configure the ISR again, as the ISR is already configured in the RAM\n \n */\n\n\n\n#ifdef MW_RUNTIME_BOOTLOADERPROGRAMMINGSUPPORT\n\n#if MW_RUNTIME_BOOTLOADERPROGRAMMINGSUPPORT != 1 ||  MW_RUNTIME_BOOTLOADERCOMPATIBLEOS == 0\n\nvoid bootloaderBackgroundTask(void)\n{\n}\nvoid bootloaderInit(void)\n{\n}\n\n\n#else\n\n#pragma DATA_SECTION(blPassCode, \"flashblpass\");\nconst uint32_T blPassCode = 0xFACE;\n\nvoid(*fpbgtask)(void);      //fp bg task it uses bg task from the BL\nuint32_T *fpdummy;\n\nvoid bootloaderInit(void)\n{\n    fpdummy = *((uint32_T*)0x0);\n    fpbgtask =  fpdummy;\n\n}\n\nvoid bootloaderBackgroundTask(void)\n{\n\n\t#if MW_RUNTIME_BOOTLOADERAPPLICATIONHASCOM == 0\n\t{\n        fpbgtask();\n    \n\t}\n\t#endif\n\n}\n#endif\n#endif\n"},{"name":"c2000HardwareTimerConfig.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2024a\\toolbox\\c2b\\tic2000\\src","tag":"","groupDisplay":"Other files","code":"/* Copyrights 2016-2021, MathWorks Inc */\n#include \"MW_target_hardware_resources.h\"\n#include \"rtwtypes.h\"\n\nvoid hardwareTimer1Init(void)\n{\n  /* InitCpuTimers() - CPU Timers are initialized in\n   * MW_c28xx_board.c in the generated code.\n   */\n  CpuTimer1Regs.PRD.all = 0xFFFFFFFF;  /* max Period*/\n  CpuTimer1Regs.TIM.all = 0xFFFFFFFF;  /* set Ctr*/\n#if defined(MW_TIMER_PRESCALE_FOR_XCP)\n  CpuTimer1Regs.TPR.all = (0xFF & (MW_TIMER_PRESCALE_FOR_XCP - 1));         /* prescaler defined in make file dynamically based on clock */\n#else\n  CpuTimer1Regs.TPR.all = 0x00;        /* no prescaler    */\n#endif\n  StartCpuTimer1();\n}\n\n/* EOF */\n"},{"name":"c2806xBoard_Realtime_Support.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2024a\\toolbox\\c2b\\tic2000\\src","tag":"","groupDisplay":"Other files","code":"#include \"MW_target_hardware_resources.h\"\n#include <math.h>\n#include <float.h>\n#include <string.h>\n\n#ifdef MW_FAST_RTS_INCLUDED\n#if DBL_MANT_DIG == FLT_MANT_DIG\nfloat cosf(float x) { return cos(x); }\nfloat sinf(float x) { return sin(x); }\nfloat sqrtf(float x) { return sqrt(x); }\nfloat atanf(float x) { return atan(x); }\nfloat atan2f(float y, float x) { return atan2(y, x); }\n#endif\n#endif\nextern Uint16 RamfuncsLoadSize;\nextern Uint16 Cla1funcsRunStart;\nextern Uint16 Cla1funcsLoadStart;\nextern Uint16 Cla1funcsLoadSize;\nextern Uint16 Cla1mathTablesRunStart;\nextern Uint16 Cla1mathTablesLoadStart;\nextern Uint16 Cla1mathTablesLoadSize;\nextern Uint16 Cla1ConstRunStart, Cla1ConstLoadStart, Cla1ConstLoadSize;\nvoid c2000_flash_init(void)\n{\n  #if MW_RUNTIME_FLASHLOAD\n  // Copy InitFlash function code and Flash setup code to RAM\n  memcpy(& RamfuncsRunStart,&RamfuncsLoadStart, (Uint32)(&RamfuncsLoadEnd-&RamfuncsLoadStart));\n  // Call Flash Initialization to setup flash waitstates\n  // This function must reside in RAM\n  /* g2486589 - Standalone mode fix */\n  InitFlash();\n  #ifdef CLA_BLOCK_INCLUDED\n    memcpy(&Cla1funcsRunStart, &Cla1funcsLoadStart, (Uint32)&Cla1funcsLoadSize);\n    memcpy(&Cla1mathTablesRunStart, &Cla1mathTablesLoadStart, (Uint32)&Cla1mathTablesLoadSize);\n    memcpy(&Cla1ConstRunStart, &Cla1ConstLoadStart, (Uint32)&Cla1ConstLoadSize);\n  #endif  \n  #endif\n}\n"},{"name":"c2806xSchedulerTimer0.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2024a\\toolbox\\c2b\\tic2000\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2015-2019 The MathWorks, Inc. */\n\n#include <stdbool.h>\n\n#include \"F2806x_Device.h\"\n#include \"F2806x_CpuTimers.h\"\n#include \"MW_c28xx_pie.h\"\n\nextern void rt_OneStep(void);\n\ninterrupt void TINT0_isr(void)\n{\n      #ifdef PIEMASK0\n        volatile unsigned int PIEIER1_stack_save = PieCtrlRegs.PIEIER1.all;\n      #endif\n      #ifdef PIEMASK1\n        volatile unsigned int PIEIER2_stack_save  = PieCtrlRegs.PIEIER2.all;\n      #endif\n      #ifdef PIEMASK2\n        volatile unsigned int PIEIER3_stack_save  = PieCtrlRegs.PIEIER3.all;\n      #endif\n      #ifdef PIEMASK3\n        volatile unsigned int PIEIER4_stack_save  = PieCtrlRegs.PIEIER4.all;\n      #endif\n      #ifdef PIEMASK4\n        volatile unsigned int PIEIER5_stack_save  = PieCtrlRegs.PIEIER5.all;\n      #endif\n      #ifdef PIEMASK5\n        volatile unsigned int PIEIER6_stack_save  = PieCtrlRegs.PIEIER6.all;\n      #endif\n      #ifdef PIEMASK6\n        volatile unsigned int PIEIER7_stack_save  = PieCtrlRegs.PIEIER7.all;\n      #endif\n      #ifdef PIEMASK7\n        volatile unsigned int PIEIER8_stack_save  = PieCtrlRegs.PIEIER8.all;\n      #endif\n      #ifdef PIEMASK8\n        volatile unsigned int PIEIER9_stack_save  = PieCtrlRegs.PIEIER9.all;\n      #endif\n      #ifdef PIEMASK9\n        volatile unsigned int PIEIER10_stack_save = PieCtrlRegs.PIEIER10.all;\n      #endif\n      #ifdef PIEMASK10\n        volatile unsigned int PIEIER11_stack_save = PieCtrlRegs.PIEIER11.all;\n      #endif\n      #ifdef PIEMASK11\n        volatile unsigned int PIEIER12_stack_save = PieCtrlRegs.PIEIER12.all;\n      #endif\n\n      #ifdef PIEMASK0\n        PieCtrlRegs.PIEIER1.all &= ~PIEMASK0;      /* disable group1 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK1\n        PieCtrlRegs.PIEIER2.all &= ~PIEMASK1;      /* disable group2 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK2\n        PieCtrlRegs.PIEIER3.all &= ~PIEMASK2;      /* disable group3 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK3\n        PieCtrlRegs.PIEIER4.all &= ~PIEMASK3;      /* disable group4 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK4\n        PieCtrlRegs.PIEIER5.all &= ~PIEMASK4;      /* disable group5 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK5\n        PieCtrlRegs.PIEIER6.all &= ~PIEMASK5;      /* disable group6 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK6\n        PieCtrlRegs.PIEIER7.all &= ~PIEMASK6;      /* disable group7 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK7\n        PieCtrlRegs.PIEIER8.all &= ~PIEMASK7;      /* disable group8 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK8\n        PieCtrlRegs.PIEIER9.all &= ~PIEMASK8;      /* disable group9 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK9\n        PieCtrlRegs.PIEIER10.all &= ~PIEMASK9;     /* disable group10 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK10\n        PieCtrlRegs.PIEIER11.all &= ~PIEMASK10;    /* disable group11 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK11\n        PieCtrlRegs.PIEIER12.all &= ~PIEMASK11;    /* disable group12 lower/equal priority interrupts */\n      #endif\n\t  #ifdef PIEMASK12\n\t\tIER &= ~(M_INT13);\n      #endif\n\t  #ifdef PIEMASK13\n\t\tIER &= ~(M_INT14);\n      #endif\n\n      asm(\" RPT #5 || NOP\");               /* wait 5 cycles */\n      IFR &= ~IFRMASK;                           /* eventually disable lower/equal priority pending interrupts */\n      PieCtrlRegs.PIEACK.all = IFRMASK;          /* ACK to allow other interrupts from the same group to fire */\n      IER |= 1;\n      EINT;                                /* global interrupt enable */\n      rt_OneStep();\n      DINT;                                /* disable global interrupts during context switch, CPU will enable global interrupts after exiting ISR */\n      #ifdef PIEMASK0\n        PieCtrlRegs.PIEIER1.all = PIEIER1_stack_save;/*restore PIEIER register that was modified */\n      #endif  \n      #ifdef PIEMASK1\n        PieCtrlRegs.PIEIER2.all = PIEIER2_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK2\n        PieCtrlRegs.PIEIER3.all = PIEIER3_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK3\n        PieCtrlRegs.PIEIER4.all = PIEIER4_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK4\n        PieCtrlRegs.PIEIER5.all = PIEIER5_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK5\n        PieCtrlRegs.PIEIER6.all = PIEIER6_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK6\n        PieCtrlRegs.PIEIER7.all = PIEIER7_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK7\n        PieCtrlRegs.PIEIER8.all = PIEIER8_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK8\n        PieCtrlRegs.PIEIER9.all = PIEIER9_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK9\n        PieCtrlRegs.PIEIER10.all= PIEIER10_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK10\n        PieCtrlRegs.PIEIER11.all= PIEIER11_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK11\n        PieCtrlRegs.PIEIER12.all= PIEIER12_stack_save;/*restore PIEIER register that was modified */\n      #endif\n\t  #ifdef PIEMASK12\n\t\tIER |= M_INT13;\n      #endif\n\t  #ifdef PIEMASK13\n\t\tIER |= M_INT14;\n      #endif\n}\n\nvoid configureTimer0(float baseRate, float systemClock)\n{\n    \n    /* InitCpuTimers() - CPU Timers are initialized in \n     * MW_c28xx_board.c in the generated code.\n     */\n\n\t/* Configure CPU-Timer 0 to interrupt every base rate. */\n\t/* Parameters:  Timer Pointer, CPU Freq in MHz, Period in usec. */\n\tConfigCpuTimer(&CpuTimer0, systemClock, baseRate * 1000000);\n\tStartCpuTimer0();\n\n\tEALLOW;\n\tPieVectTable.TINT0 = &TINT0_isr;     /* Hook interrupt to the ISR*/\n\tEDIS;\n\n\tPieCtrlRegs.PIEIER1.bit.INTx7 = 1;   /* Enable interrupt TINT0 */\n\tIER |= M_INT1;\n}\n\nvoid enableTimer0Interrupt(void)\n{\n\tasm(\" SETC INTM\"); /* Disable Interrupt Global Enable Bit - set it to 1 */\n\tPieCtrlRegs.PIEIER1.all |= (1 << 6); /* Enable PIER bit for timer 0 */\n\tasm(\" CLRC INTM\"); /* Enable Interrupt Global Enable Bit - set it to 0 */\n}\n\nbool disableTimer0Interrupt(void)\n{\n    bool isrEnabled = false;\n\tasm(\" SETC INTM\"); /* Disable Interrupt Global Enable Bit - set it to 1 */\n    isrEnabled = PieCtrlRegs.PIEIER1.all & (1 << 6) ;\n    PieCtrlRegs.PIEIER1.all &= ~(1 << 6); /* Disable PIER bit for timer 0 */\n\tasm(\" RPT #5 || NOP\");\n\tIFR &= 0xFFFE;\n\tPieCtrlRegs.PIEACK.all = 0x1;\n\tasm(\" CLRC INTM\"); /* Enable Interrupt Global Enable Bit - set it to 0 */\n    return isrEnabled;\n}\n\nvoid restoreTimer0Interrupt(bool isrStatus){\n    if(isrStatus)\n        enableTimer0Interrupt();\n    else\n        disableTimer0Interrupt();\n}\n"},{"name":"mw_soc_c2000_ipc.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2024a\\toolbox\\c2b\\tic2000_soc\\src\\ipclite","tag":"","groupDisplay":"Other files","code":"/* mw_soc_c2000_ipc.c\n*\n* Copyright 2023 The MathWorks, Inc.\n*\n*/\n#ifdef IPC_BLOCK_INCLUDED\n#include \"mw_soc_c2000_ipc.h\"\n\n#ifndef __TMS320C28XX_CLA__\n#pragma CODE_SECTION(MW_IPC_Write, \"ramfuncs\");\n#pragma CODE_SECTION(MW_IPC_Read, \"ramfuncs\");\n#endif\n\n\n#define DEBUG  0  /* Debugging info 1:on 0:off */\n#if DEBUG\n#include <stdlib.h> /*printf*/\n#endif\n#ifndef __TMS320C28XX_CLA__\n#include <string.h> /* for memcpy*/\n#endif /*__TMS320C28XX_CLA__*/\n\n/* Add each channel (symbols) some sections and assign to the GS0 or GS1.\n* The size of the symbols shall reflect the dataLength of the data to be sent.\n* On receive, we will use the senders CPU location in GS and access it, not required to set any length.\n*/\n#define IPC_DTYPE_INDEX_32_BITS     0x00000006 /* From index 6 data type needs 32 bits (1-5 index needs 15 bits, 6-8 index needs 32 bits)*/\n\n#define ADDRESS_GRANULATIRY (2)\n\n#ifndef __TMS320C28XX_CLA__\n#pragma DATA_SECTION(ipcHandleForCLA,\"Cla1DataRam0\")\n\nvolatile uint32_T buffAddrCLAToCPU;\nvolatile uint32_T buffAddrCPUToCLA;\n\nvolatile uint32_T blkC1CLA1ChIndex = 0;\n\n\nvolatile IPCChannelStruct_T ipcChannelCPU1ToCPU1CLA1[MW_NUM_IPC_CHANNELS];\nvolatile IPCChannelStruct_T ipcChannelCPU1CLA1ToCPU1[MW_NUM_IPC_CHANNELS];\n\n/* Every connection betweeen 2 processing units requires an independent ipcHandle\n* In this 2D array,\n*      each row corresponds to one connection between 2 PUs,\n*      and each column corresponds to one channel\n* For example,\n*      ipcHandle[0][2] --> 2nd channel of CPU1 to CPU2 channel\n*      ipcHandle[2][0] --> 0th channel of CPU2 to CM channel\n* This will be used with notation ipcHandle[IpcParams->IPCBetween][IpcParams->ChNum]\n*\n* ipcHandle[0][x] --> CPU1 CPU2 channel\n* ipcHandle[1][x] --> CPU1 CM channel\n* ipcHandle[2][x] --> CPU2 CM channel\n*/\nvolatile IPC_CPUHandle_T ipcHandle[MW_NUM_IPC_CHANNELS];\nvolatile IPC_CPUHandle_T ipcHandleForCLA[MW_NUM_IPC_CHANNELS];\n\nMW_IPC_Handle MW_IPC_Init(MW_IPC_Params_T *IpcParams)\n{\n    uint32_T ipcflag = 0x00000001, ipcflag1;\n    /* Reset the IPC Status flags*/\n    ipcflag1 = ipcflag << IpcParams->ChNum;\n\n\n    #if defined(CPU1_CLA_IPC)\n    if(IpcParams->IPCBetween == IPC_CPU1CLA)\n    {\n        /* CPU1 to CLA channel init */\n        blkC1CLA1ChIndex = IpcParams->ChNum;\n        ipcChannelCPU1ToCPU1CLA1[blkC1CLA1ChIndex].numOfBuffers = IpcParams->NumOfBuffers;\n        ipcChannelCPU1ToCPU1CLA1[blkC1CLA1ChIndex].intEnable = IpcParams->IsIntEnabled;\n        ipcChannelCPU1ToCPU1CLA1[blkC1CLA1ChIndex].chNum = IpcParams->ChNum;\n\n        buffAddrCPUToCLA = CPUTOCLA_SHRD_MSG_RAM + (blkC1CLA1ChIndex*100*sizeof(uint16_T));\n\n        ipcChannelCPU1ToCPU1CLA1[blkC1CLA1ChIndex].head.ptr = (uint16_T *)buffAddrCPUToCLA;\n        ipcChannelCPU1ToCPU1CLA1[blkC1CLA1ChIndex].tail.ptr = (uint16_T *)(buffAddrCPUToCLA + 1*sizeof(uint16_T));\n        ipcChannelCPU1ToCPU1CLA1[blkC1CLA1ChIndex].full.ptr = (uint16_T *)(buffAddrCPUToCLA + 2*sizeof(uint16_T));\n        ipcChannelCPU1ToCPU1CLA1[blkC1CLA1ChIndex].mutex.ptr = (uint16_T *)(buffAddrCPUToCLA + 3*sizeof(uint16_T));\n        ipcChannelCPU1ToCPU1CLA1[blkC1CLA1ChIndex].overwrite.ptr = (uint16_T *)(buffAddrCPUToCLA + 4*sizeof(uint16_T));\n        ipcChannelCPU1ToCPU1CLA1[blkC1CLA1ChIndex].lastReadStatus.ptr = (uint16_T *)(buffAddrCPUToCLA + 5*sizeof(uint16_T));\n        ipcChannelCPU1ToCPU1CLA1[blkC1CLA1ChIndex].bufferLength.ptr = (uint16_T *)(buffAddrCPUToCLA + 6*sizeof(uint16_T));\n        ipcChannelCPU1ToCPU1CLA1[blkC1CLA1ChIndex].dataTypeInBytes.ptr =  (uint16_T *)(buffAddrCPUToCLA + 7*sizeof(uint16_T));  /* actual data resides after control flags in MSGRAM*/\n        ipcChannelCPU1ToCPU1CLA1[blkC1CLA1ChIndex].bufferStartAdd.ptr =  (uint16_T *)(buffAddrCPUToCLA + 8*sizeof(uint16_T));  /* actual data resides after control flags in MSGRAM*/\n\n        *(ipcChannelCPU1ToCPU1CLA1[blkC1CLA1ChIndex].head.ptr) = 0;\n        *(ipcChannelCPU1ToCPU1CLA1[blkC1CLA1ChIndex].tail.ptr) = 0;\n        *(ipcChannelCPU1ToCPU1CLA1[blkC1CLA1ChIndex].full.ptr) = 0;\n        *(ipcChannelCPU1ToCPU1CLA1[blkC1CLA1ChIndex].mutex.ptr) = 0;\n        *(ipcChannelCPU1ToCPU1CLA1[blkC1CLA1ChIndex].overwrite.ptr) = 0;\n        *(ipcChannelCPU1ToCPU1CLA1[blkC1CLA1ChIndex].lastReadStatus.ptr) = 0;\n        *(ipcChannelCPU1ToCPU1CLA1[blkC1CLA1ChIndex].bufferLength.ptr) =  IpcParams->BufferSize;\n        *(ipcChannelCPU1ToCPU1CLA1[blkC1CLA1ChIndex].dataTypeInBytes.ptr) = (ADDRESS_GRANULATIRY > IpcParams->DataTypeInBytes) ? ADDRESS_GRANULATIRY : IpcParams->DataTypeInBytes;\n\n        /* CLA to CPU1 channel init */\n        blkC1CLA1ChIndex = IpcParams->ChNum;\n        ipcChannelCPU1CLA1ToCPU1[blkC1CLA1ChIndex].numOfBuffers = IpcParams->NumOfBuffers;\n        ipcChannelCPU1CLA1ToCPU1[blkC1CLA1ChIndex].intEnable = IpcParams->IsIntEnabled;\n        ipcChannelCPU1CLA1ToCPU1[blkC1CLA1ChIndex].chNum = IpcParams->ChNum;\n\n        buffAddrCLAToCPU = CLATOCPU_SHRD_MSG_RAM + (blkC1CLA1ChIndex*100*sizeof(uint16_T));\n\n        ipcChannelCPU1CLA1ToCPU1[blkC1CLA1ChIndex].head.ptr = (uint16_T *)buffAddrCLAToCPU;\n        ipcChannelCPU1CLA1ToCPU1[blkC1CLA1ChIndex].tail.ptr = (uint16_T *)(buffAddrCLAToCPU + 1*sizeof(uint16_T));\n        ipcChannelCPU1CLA1ToCPU1[blkC1CLA1ChIndex].full.ptr = (uint16_T *)(buffAddrCLAToCPU + 2*sizeof(uint16_T));\n        ipcChannelCPU1CLA1ToCPU1[blkC1CLA1ChIndex].mutex.ptr = (uint16_T *)(buffAddrCLAToCPU + 3*sizeof(uint16_T));\n        ipcChannelCPU1CLA1ToCPU1[blkC1CLA1ChIndex].overwrite.ptr = (uint16_T *)(buffAddrCLAToCPU + 4*sizeof(uint16_T));\n        ipcChannelCPU1CLA1ToCPU1[blkC1CLA1ChIndex].lastReadStatus.ptr = (uint16_T *)(buffAddrCLAToCPU + 5*sizeof(uint16_T));\n        ipcChannelCPU1CLA1ToCPU1[blkC1CLA1ChIndex].bufferLength.ptr = (uint16_T *)(buffAddrCLAToCPU + 6*sizeof(uint16_T));\n        ipcChannelCPU1CLA1ToCPU1[blkC1CLA1ChIndex].dataTypeInBytes.ptr =  (uint16_T *)(buffAddrCLAToCPU + 7*sizeof(uint16_T));  /* actual data resides after control flags in MSGRAM*/\n        ipcChannelCPU1CLA1ToCPU1[blkC1CLA1ChIndex].bufferStartAdd.ptr =  (uint16_T *)(buffAddrCLAToCPU + 8*sizeof(uint16_T));  /* actual data resides after control flags in MSGRAM*/\n\n        *(ipcChannelCPU1CLA1ToCPU1[blkC1CLA1ChIndex].head.ptr) = 0;\n        *(ipcChannelCPU1CLA1ToCPU1[blkC1CLA1ChIndex].tail.ptr) = 0;\n        *(ipcChannelCPU1CLA1ToCPU1[blkC1CLA1ChIndex].full.ptr) = 0;\n        *(ipcChannelCPU1CLA1ToCPU1[blkC1CLA1ChIndex].mutex.ptr) = 0;\n        *(ipcChannelCPU1CLA1ToCPU1[blkC1CLA1ChIndex].overwrite.ptr) = 0;\n        *(ipcChannelCPU1CLA1ToCPU1[blkC1CLA1ChIndex].lastReadStatus.ptr) = 0;\n        *(ipcChannelCPU1CLA1ToCPU1[blkC1CLA1ChIndex].bufferLength.ptr) =  IpcParams->BufferSize;\n        *(ipcChannelCPU1CLA1ToCPU1[blkC1CLA1ChIndex].dataTypeInBytes.ptr) = (ADDRESS_GRANULATIRY > IpcParams->DataTypeInBytes) ? ADDRESS_GRANULATIRY : IpcParams->DataTypeInBytes;\n\n        ipcHandleForCLA[blkC1CLA1ChIndex].H_PU1 = ipcChannelCPU1ToCPU1CLA1[blkC1CLA1ChIndex];\n        ipcHandleForCLA[blkC1CLA1ChIndex].H_PU2 = ipcChannelCPU1CLA1ToCPU1[blkC1CLA1ChIndex];\n        ipcHandleForCLA[blkC1CLA1ChIndex].H_IPCBetween = IpcParams->IPCBetween;\n        blkC1CLA1ChIndex = blkC1CLA1ChIndex +1;\n    }\n    #endif\n\n    if(IpcParams->IPCBetween == IPC_CPU1CLA)\n        return (MW_IPC_Handle) ipcHandleForCLA[IpcParams->ChNum];\n    else /*non reachable code*/\n        return (MW_IPC_Handle) ipcHandle[IpcParams->ChNum];\n}\n\nvoid MW_IPC_Terminate(MW_IPC_Handle ipcHandle)\n{\n    /* add later*/\n}\n/* ZG: \n1. bufferingSupported Y default\n2. \n3. error could be added to the block in start callback and may be init. \n4. check if we change the board, what happened\n5. test case: Selected board supported it,  then check for board when we change the board.\n*/\n\n#endif /*ifndef __TMS320C28XX_CLA__ ended*/\n\n#ifdef __TMS320C28XX_CLA__\nvoid MW_IPC_Write_CLA(MW_IPC_Handle* ipcHandle, uint16_T CurrentPU, uint16_T DataTypeId, MW_Void_Ptr_T dataToSend)\n{\n    uint16_T head =  *(ipcHandle->H_PU2).head.ptr;\n    uint16_T tail;\n    uint16_T dataInBytes = *(ipcHandle->H_PU2).bufferLength.ptr * (*(ipcHandle->H_PU2).dataTypeInBytes.ptr);\n    uint16_T dataInWords = dataInBytes/2;\n    /* if ABI=COFF, then double is 32bits. This has to be corrected as follows*/\n    #if defined(COFF_DOUBLE_SIZE_CORRECTION)\n    if(DataTypeId==MW_DOUBLE)\n    {\n        dataInBytes = dataInBytes/2;\n        dataInWords = dataInWords/2;\n    }\n    #endif /*COFF_DOUBLE_SIZE_CORRECTION*/\n\n    while(*(ipcHandle->H_PU1).mutex.ptr);\n    {\n        *(ipcHandle->H_PU2).mutex.ptr = 1;\n        memcpy_cla((ipcHandle->H_PU2).bufferStartAdd.ptr, dataToSend, dataInWords);\n        *(ipcHandle->H_PU2).mutex.ptr = 0; /*unlock the mutex*/\n    }\n}\n\nvoid MW_IPC_Read_CLA(MW_IPC_Handle* ipcHandle, uint16_T CurrentPU, uint16_T DataTypeId, MW_Void_Ptr_T dataTobeRead, int8_T* status)\n{\n    uint16_T tail;\n    *status = 0;\n    uint16_T dataInBytes = *(ipcHandle->H_PU2).bufferLength.ptr * (*(ipcHandle->H_PU2).dataTypeInBytes.ptr);\n    uint16_T dataInWords = dataInBytes/2;\n    /* if ABI=COFF, then double is 32bits. This has to be corrected as follows*/\n    #if defined(COFF_DOUBLE_SIZE_CORRECTION)\n    if(DataTypeId==MW_DOUBLE)\n    {\n        dataInBytes = dataInBytes/2;\n        dataInWords = dataInWords/2;\n    }\n    #endif /*COFF_DOUBLE_SIZE_CORRECTION*/\n    if(((*(ipcHandle->H_PU2).dataTypeInBytes.ptr) != (*(ipcHandle->H_PU1).dataTypeInBytes.ptr)) && (*(ipcHandle->H_PU1).bufferLength.ptr != *(ipcHandle->H_PU2).bufferLength.ptr))\n    {\n        *status = 6;\n    }\n    else if((*(ipcHandle->H_PU2).dataTypeInBytes.ptr) != (*(ipcHandle->H_PU1).dataTypeInBytes.ptr))\n    {\n        *status = 2;\n    }\n    else if (*(ipcHandle->H_PU1).bufferLength.ptr != *(ipcHandle->H_PU2).bufferLength.ptr)\n    {\n        *status = 4;\n    }\n    while(*(ipcHandle->H_PU1).mutex.ptr); /* wait while writing CPU is updating its flags */\n    {   \n        *(ipcHandle->H_PU2).mutex.ptr = 1; /* lock mutex */\n        memcpy_cla(dataTobeRead, (ipcHandle->H_PU1).bufferStartAdd.ptr, dataInWords);\n        *(ipcHandle->H_PU2).mutex.ptr = 0; /*unlock the mutex*/\n\n    }\n}\n\nvoid memcpy_cla(void *dest, void *src, uint16_T n)\n{\n    char_T *csrc = (char_T *)src;\n    char_T *cdest = (char_T *)dest;\n    uint16_T i=0;\n    for (;i<n; ++i)\n        cdest[i] = csrc[i];\n}\n#endif /*__TMS320C28XX_CLA__*/\n\n#ifndef __TMS320C28XX_CLA__\nvoid MW_IPC_Write(MW_IPC_Handle* ipcHandle, uint16_T CurrentPU, uint16_T DataTypeId, MW_Void_Ptr_T dataToSend, MW_IPC_Diag_T *diagDataOut)\n{\n    /* Processing Unit 1 */\n    {\n        uint16_T head =  *(ipcHandle->H_PU1).head.ptr;\n        uint16_T tail;\n        uint16_T dataInBytes = *(ipcHandle->H_PU1).bufferLength.ptr * (*(ipcHandle->H_PU1).dataTypeInBytes.ptr);\n        uint16_T dataInWords = dataInBytes/2; /* 16 bit int size is 1 word*/\n        /* if ABI=COFF, then double is 32bits. This has to be corrected as follows*/\n        #if defined(COFF_DOUBLE_SIZE_CORRECTION)\n        if(DataTypeId==MW_DOUBLE)\n        {\n            dataInBytes = dataInBytes/2;\n            dataInWords = dataInWords/2;\n        }\n        #endif /*COFF_DOUBLE_SIZE_CORRECTION*/\n\n        while(*(ipcHandle->H_PU2).mutex.ptr); /* sleep until mutex is locked by CLA*/\n        {\n            *(ipcHandle->H_PU1).mutex.ptr = 1; /*lock the mutex*/\n            memcpy((ipcHandle->H_PU1).bufferStartAdd.ptr, dataToSend, dataInWords);\n            *(ipcHandle->H_PU1).mutex.ptr = 0; /*unlock the mutex*/\n        }\n    }\n}\n\nvoid MW_IPC_Read(MW_IPC_Handle* ipcHandle, uint16_T CurrentPU, uint16_T DataTypeId, MW_Void_Ptr_T dataTobeRead, int8_T* status)\n{\n    /*  Do all statuts should be update in both CPU1 & PU2 & CLA\n    0 — No errors\n    1 — Data not available\n    2 — Data type mismatch => uint16_T dataInBytes = *(ipcHandle->H_PU2).bufferLength.ptr * (*(ipcHandle->H_PU2).dataTypeInBytes.ptr); & DataTypeId should match\n    4 — Data length mismatch => *(ipcHandle->H_PU1).bufferLength.ptr should be checked against *(ipcHandle->H_PU2).bufferLength.ptr;\n    6 — Data type and Data length mismatch\n    */\n    *status = 0;\n    \n    {\n        uint16_T tail;\n        uint16_T dataInBytes = *(ipcHandle->H_PU1).bufferLength.ptr * (*(ipcHandle->H_PU1).dataTypeInBytes.ptr);\n        uint16_T dataInWords = dataInBytes/2;\n        /* if ABI=COFF, then double is 32bits. This has to be corrected as follows*/\n        #if defined(COFF_DOUBLE_SIZE_CORRECTION)\n        if(DataTypeId==MW_DOUBLE)\n        {\n            dataInBytes = dataInBytes/2;\n            dataInWords = dataInWords/2;\n        }\n        #endif /*COFF_DOUBLE_SIZE_CORRECTION*/\n\n        if(((*(ipcHandle->H_PU2).dataTypeInBytes.ptr) != (*(ipcHandle->H_PU1).dataTypeInBytes.ptr)) && (*(ipcHandle->H_PU1).bufferLength.ptr != *(ipcHandle->H_PU2).bufferLength.ptr))\n        {\n            *status = 6;\n        }\n        else if((*(ipcHandle->H_PU2).dataTypeInBytes.ptr) != (*(ipcHandle->H_PU1).dataTypeInBytes.ptr))\n        {\n            *status = 2;\n        }\n        else if (*(ipcHandle->H_PU1).bufferLength.ptr != *(ipcHandle->H_PU2).bufferLength.ptr)\n        {\n            *status = 4;\n        }\n        while(*(ipcHandle->H_PU2).mutex.ptr);\n        {\n            *(ipcHandle->H_PU1).mutex.ptr = 1;\n            memcpy(dataTobeRead, (ipcHandle->H_PU2).bufferStartAdd.ptr, dataInWords);\n            *(ipcHandle->H_PU1).mutex.ptr = 0; /*unlock the mutex*/\n\n\n        }\n    }\n    return status;\n}\n\n#endif /* not CLA*/\n\n#endif /*IPC_BLOCK_INCLUDED*/\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true,"showProtectedV2Report":true}};